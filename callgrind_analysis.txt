--------------------------------------------------------------------------------
Profile data file 'callgrind_multi_producer.out' (creator: callgrind-3.24.0)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 20614685
Trigger: Program termination
Profiled target:  ./target/debug/examples/multi_producer (PID 186820, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
118,165,724 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                  file:function
--------------------------------------------------------------------------------
8,128,000 ( 6.88%)  src/coordinator/sequencer.rs:<oxidator::coordinator::sequencer::MultiProducerSequencer<W> as oxidator::traits::traits::Sequencer>::publish [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
6,336,858 ( 5.36%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::slice::raw::from_raw_parts::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
4,512,423 ( 3.82%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_compare_exchange [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
4,480,064 ( 3.79%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<core::ops::range::RangeInclusive<T> as core::iter::range::RangeInclusiveIteratorImpl>::spec_next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
4,242,202 ( 3.59%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_load [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
3,840,520 ( 3.25%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:core::slice::raw::from_raw_parts::precondition_check
3,776,000 ( 3.20%)  src/producer/producer.rs:<oxidator::producer::producer::Producer<T,S,D> as oxidator::traits::traits::EventProducer>::write [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
3,374,592 ( 2.86%)  samples/multi_producer_sample.rs:<multi_producer::SumTask as oxidator::traits::traits::Task<multi_producer::Event>>::execute_task [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
2,496,116 ( 2.11%)  samples/multi_producer_sample.rs:multi_producer::main::{{closure}} [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
2,432,558 ( 2.06%)  src/consumer/consumer.rs:<oxidator::consumer::consumer::Consumer<T,F,D,S> as oxidator::traits::traits::Worker>::run [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
2,176,000 ( 1.84%)  src/storage/ring_buffer.rs:<oxidator::storage::ring_buffer::RingBuffer<T> as oxidator::traits::traits::DataStorage<T>>::get_data [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,824,072 ( 1.54%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs:<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,736,747 ( 1.47%)  ???:_int_free [/usr/lib64/libc.so.6]
1,728,234 ( 1.46%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:core::slice::raw::from_raw_parts::precondition_check
1,537,050 ( 1.30%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,536,095 ( 1.30%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::index [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,472,092 ( 1.25%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::size_hint [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,443,906 ( 1.22%)  ???:malloc [/usr/lib64/libc.so.6]
1,344,298 ( 1.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,312,000 ( 1.11%)  src/coordinator/sequencer.rs:<oxidator::coordinator::sequencer::MultiProducerSequencer<W> as oxidator::traits::traits::Sequencer>::next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,253,267 ( 1.06%)  ???:free [/usr/lib64/libc.so.6]
1,248,078 ( 1.06%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,248,000 ( 1.06%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,216,320 ( 1.03%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_store [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,157,625 ( 0.98%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::load [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,152,016 ( 0.97%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:<core::ops::range::RangeInclusive<T> as core::iter::range::RangeInclusiveIteratorImpl>::spec_next
1,088,000 ( 0.92%)  src/storage/ring_buffer.rs:<oxidator::storage::ring_buffer::RingBuffer<T> as oxidator::traits::traits::DataStorage<T>>::get_data_mut [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,088,000 ( 0.92%)  src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::compare_exchange [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,056,999 ( 0.89%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::Global::alloc_impl [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,056,099 ( 0.89%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs:std::sync::poison::map_result [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,056,000 ( 0.89%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:core::slice::<impl [T]>::get_unchecked [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,024,064 ( 0.87%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:core::iter::traits::exact_size::ExactSizeIterator::len [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
1,024,000 ( 0.87%)  src/traits/traits.rs:<alloc::boxed::Box<dyn oxidator::traits::traits::Task<T>+core::marker::Sync+core::marker::Send> as oxidator::traits::traits::Task<T>>::execute_task [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  960,130 ( 0.81%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/raw.rs:core::slice::raw::from_raw_parts::precondition_check
  960,110 ( 0.81%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::as_slice [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  960,040 ( 0.81%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::RangeInclusive<A>>::next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  928,116 ( 0.79%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  899,832 ( 0.76%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::sync::atomic::atomic_load
  896,000 ( 0.76%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::compare_exchange [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  864,783 ( 0.73%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::exchange_malloc [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  817,566 ( 0.69%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<core::ops::range::Range<T> as core::iter::range::RangeIteratorImpl>::spec_next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  800,117 ( 0.68%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  772,219 ( 0.65%)  ???:__memcpy_avx_unaligned_erms [/usr/lib64/libc.so.6]
  768,048 ( 0.65%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:core::iter::traits::exact_size::ExactSizeIterator::len
  768,000 ( 0.65%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:<core::ops::range::RangeInclusive<T> as core::iter::range::RangeInclusiveIteratorImpl>::spec_next
  767,904 ( 0.65%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:<i64 as core::iter::range::Step>::forward_unchecked
  704,457 ( 0.60%)  ???:alloc::raw_vec::RawVecInner<A>::deallocate [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  676,375 ( 0.57%)  src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::load [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  672,042 ( 0.57%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
  672,000 ( 0.57%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI32::fetch_add [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  640,580 ( 0.54%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:core::ptr::read_volatile::precondition_check
  640,080 ( 0.54%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::store [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  608,057 ( 0.51%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::Mutex<T>::lock [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  578,745 ( 0.49%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:core::ptr::non_null::NonNull<T>::sub_ptr [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  576,522 ( 0.49%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::ptr::read_volatile::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  544,068 ( 0.46%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<T,A> as core::ops::drop::Drop>::drop [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  544,051 ( 0.46%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs:std::sync::poison::Flag::guard [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  512,350 ( 0.43%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref
  512,032 ( 0.43%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:core::iter::traits::exact_size::ExactSizeIterator::len
  512,000 ( 0.43%)  src/coordinator/sequencer.rs:oxidator::coordinator::sequencer::MultiProducerSequencer<W>::buffer_has_capacity [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  480,055 ( 0.41%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::deref::Deref>::deref [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  480,055 ( 0.41%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:alloc::vec::Vec<T,A>::as_slice
  480,000 ( 0.41%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  480,000 ( 0.41%)  samples/multi_producer_sample.rs:multi_producer::main::{{closure}}::{{closure}} [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  450,141 ( 0.38%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:core::ptr::non_null::NonNull<T>::sub_ptr
  448,056 ( 0.38%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:core::ops::range::RangeInclusive<Idx>::new [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  448,042 ( 0.38%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::drop::Drop>::drop [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  416,072 ( 0.35%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  416,028 ( 0.35%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::next
  384,276 ( 0.33%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::ptr::non_null::NonNull<T>::new_unchecked::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  384,052 ( 0.33%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::slice::raw::from_raw_parts::precondition_check
  384,036 ( 0.32%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::sync::atomic::atomic_compare_exchange
  384,036 ( 0.32%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:std::sync::poison::mutex::Mutex<T>::lock
  384,036 ( 0.32%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:std::sync::poison::Flag::guard
  383,952 ( 0.32%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<i64 as core::iter::range::Step>::forward_unchecked [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  352,011 ( 0.30%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:alloc::slice::hack::into_vec [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  321,525 ( 0.27%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::ptr::const_ptr::<impl *const T>::sub_ptr::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  320,290 ( 0.27%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::alloc [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  320,064 ( 0.27%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next
  320,040 ( 0.27%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter
  320,030 ( 0.27%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:std::sync::poison::Flag::guard
  320,020 ( 0.27%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:core::iter::traits::exact_size::ExactSizeIterator::len
  306,540 ( 0.26%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<usize as core::iter::range::Step>::forward_unchecked [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  288,267 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:alloc::alloc::Global::alloc_impl
  288,261 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:core::ptr::read_volatile::precondition_check
  288,033 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::len [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  288,027 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs:std::sync::poison::Flag::done [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  288,009 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:alloc::slice::<impl [T]>::into_vec [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  288,003 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs:core::iter::traits::iterator::Iterator::enumerate
  288,000 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:core::mem::drop [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  288,000 ( 0.24%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked
  256,424 ( 0.22%)  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/sys/alloc/unix.rs:__rdl_alloc
  256,064 ( 0.22%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::sync::atomic::atomic_store
  256,024 ( 0.22%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:std::sync::poison::Flag::done
  256,000 ( 0.22%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:<multi_producer::SumTask as oxidator::traits::traits::Task<multi_producer::Event>>::execute_task
  224,378 ( 0.19%)  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/core/src/alloc/layout.rs:core::alloc::layout::Layout::is_size_align_valid [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  224,161 ( 0.19%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::raw_vec::RawVec<T,A> as core::ops::drop::Drop>::drop [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  224,021 ( 0.19%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::drop::Drop>::drop
  224,021 ( 0.19%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::MutexGuard<T>::new::{{closure}} [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  224,021 ( 0.19%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/mutex/futex.rs:std::sync::poison::mutex::Mutex<T>::lock
  224,000 ( 0.19%)  samples/multi_producer_sample.rs:<multi_producer::PrinterTask as oxidator::traits::traits::Task<multi_producer::Event>>::execute_task [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  201,984 ( 0.17%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::DerefMut>::deref_mut [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  192,915 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:core::ptr::non_null::NonNull<T>::sub_ptr
  192,324 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:core::alloc::layout::Layout::from_size_align_unchecked::precondition_check
  192,324 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::alloc::layout::Layout::from_size_align_unchecked::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  192,324 ( 0.16%)  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/core/src/ptr/alignment.rs:core::alloc::layout::Layout::is_size_align_valid
  192,138 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:core::ptr::non_null::NonNull<T>::new_unchecked::precondition_check
  192,036 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next
  192,026 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:core::slice::raw::from_raw_parts::precondition_check
  192,026 ( 0.16%)  samples/multi_producer_sample.rs:core::slice::raw::from_raw_parts::precondition_check
  192,024 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter
  192,022 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::vec::Vec<T,A>::as_slice
  192,018 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:std::sync::poison::Flag::done
  192,012 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
  192,012 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
  192,009 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  192,006 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:alloc::slice::hack::into_vec
  192,000 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::is_empty [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  192,000 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:core::result::Result<T,E>::is_ok [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  192,000 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check
  191,976 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:<i64 as core::iter::range::Step>::forward_unchecked
  191,976 ( 0.16%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<core::ops::range::RangeInclusive<T> as core::iter::range::RangeInclusiveIteratorImpl>::spec_next
  171,805 ( 0.15%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::num::<impl usize>::unchecked_add::precondition_check [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  170,345 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  160,163 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:alloc::alloc::Global::alloc_impl
  160,145 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:alloc::alloc::alloc
  160,015 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::sync::poison::mutex::MutexGuard<multi_producer::EventCounters>> [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  160,000 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<multi_producer::Event,alloc::alloc::Global>> [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  160,000 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::raw_vec::RawVec<multi_producer::Event>> [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  160,000 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::vec::into_iter::IntoIter<multi_producer::Event>> [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  160,000 ( 0.14%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<core::iter::adapters::enumerate::Enumerate<alloc::vec::into_iter::IntoIter<multi_producer::Event>>> [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  128,610 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:core::ptr::const_ptr::<impl *const T>::sub_ptr::precondition_check
  128,116 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:alloc::alloc::alloc
  128,020 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop
  128,016 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<T,A> as core::ops::drop::Drop>::drop
  128,016 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/niche_types.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter
  128,016 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter
  128,012 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/mutex/futex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::drop::Drop>::drop
  128,004 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::slice::hack::into_vec
  128,000 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:core::result::Result<T,E>::is_ok
  128,000 ( 0.11%)  samples/multi_producer_sample.rs:<multi_producer::Event as core::clone::Clone>::clone [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
  127,984 ( 0.11%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:<i64 as core::iter::range::Step>::forward_unchecked
  103,083 ( 0.09%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:core::num::<impl usize>::unchecked_add::precondition_check
  102,180 ( 0.09%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:<usize as core::iter::range::Step>::forward_unchecked
   96,097 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:alloc::alloc::Global::alloc_impl
   96,091 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs:alloc::alloc::Global::alloc_impl
   96,087 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:alloc::alloc::Global::alloc_impl
   96,087 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::read_volatile::precondition_check
   96,087 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:alloc::alloc::Global::alloc_impl
   96,087 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:alloc::alloc::exchange_malloc
   96,006 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
   96,003 ( 0.08%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::slice::hack::into_vec
   68,138 ( 0.06%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:<core::ops::range::Range<T> as core::iter::range::RangeIteratorImpl>::spec_next
   67,328 ( 0.06%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::DerefMut>::deref_mut
   64,384 ( 0.05%)  /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c:do_lookup_x [/usr/lib64/ld-linux-x86-64.so.2]
   64,305 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:core::ptr::non_null::NonNull<T>::sub_ptr
   64,305 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:core::ptr::non_null::NonNull<T>::sub_ptr
   64,114 ( 0.05%)  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/alloc.rs:__rdl_dealloc [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
   64,114 ( 0.05%)  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/sys/alloc/unix.rs:__rdl_dealloc
   64,058 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:alloc::alloc::alloc
   64,058 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:alloc::alloc::exchange_malloc
   64,058 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::ptr::read_volatile::precondition_check
   64,058 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/alignment.rs:alloc::alloc::alloc
   64,040 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next
   64,018 ( 0.05%)  src/coordinator/wait.rs:<oxidator::coordinator::wait::YieldingWaitStrategy as oxidator::traits::traits::WaitStrategy>::signal [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
   64,012 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next
   64,008 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/niche_types.rs:<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<T,A> as core::ops::drop::Drop>::drop
   64,008 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter
   64,008 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<T,A> as core::ops::drop::Drop>::drop
   64,008 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop
   64,006 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::drop::Drop>::drop
   64,006 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:std::sync::poison::mutex::Mutex<T>::lock
   64,006 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:std::sync::poison::mutex::Mutex<T>::lock
   64,004 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:core::iter::traits::iterator::Iterator::enumerate [/home/akshay_kumar/Code/OSS/rust/oxidater/target/debug/examples/multi_producer]
   64,003 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref
   64,002 ( 0.05%)  /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:alloc::slice::hack::into_vec

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs
--------------------------------------------------------------------------------
Ir               

-- line 129 ----------------------------------------
      .               pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
      .                   assert_unsafe_precondition!(
      .                       check_library_ub,
      .                       "Layout::from_size_align_unchecked requires that align is a power of 2 \
      .                       and the rounded-up allocation size does not exceed isize::MAX",
      .                       (
      .                           size: usize = size,
      .                           align: usize = align,
192,324 ( 0.16%)              ) => Layout::is_size_align_valid(size, align)
416,702 ( 0.35%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/core/src/alloc/layout.rs:core::alloc::layout::Layout::is_size_align_valid (32,054x)
      .                   );
      .                   // SAFETY: the caller is required to uphold the preconditions.
 64,079 ( 0.05%)          unsafe { Layout { size, align: mem::transmute(align) } }
      .               }
      .           
      .               /// The minimum size in bytes for a memory block of this layout.
      .               #[stable(feature = "alloc_layout", since = "1.28.0")]
      .               #[rustc_const_stable(feature = "const_alloc_layout_size_align", since = "1.50.0")]
      .               #[must_use]
      .               #[inline]
      .               pub const fn size(&self) -> usize {
128,170 ( 0.11%)          self.size
      .               }
      .           
      .               /// The minimum byte alignment for a memory block of this layout.
      .               ///
      .               /// The returned alignment is guaranteed to be a power of two.
      .               #[stable(feature = "alloc_layout", since = "1.28.0")]
      .               #[rustc_const_stable(feature = "const_alloc_layout_size_align", since = "1.50.0")]
      .               #[must_use = "this returns the minimum alignment, \
      .                             without modifying the layout"]
      .               #[inline]
      .               pub const fn align(&self) -> usize {
 32,051 ( 0.03%)          self.align.as_usize()
      .               }
      .           
      .               /// Constructs a `Layout` suitable for holding a value of type `T`.
      .               #[stable(feature = "alloc_layout", since = "1.28.0")]
      .               #[rustc_const_stable(feature = "alloc_layout_const_new", since = "1.42.0")]
      .               #[must_use]
      .               #[inline]
      .               pub const fn new<T>() -> Self {
-- line 169 ----------------------------------------
-- line 228 ----------------------------------------
      .               /// Note that the pointer value may potentially represent a valid pointer,
      .               /// which means this must not be used as a "not yet initialized"
      .               /// sentinel value. Types that lazily allocate must track initialization by
      .               /// some other means.
      .               #[unstable(feature = "alloc_layout_extra", issue = "55724")]
      .               #[must_use]
      .               #[inline]
      .               pub const fn dangling(&self) -> NonNull<u8> {
      4 ( 0.00%)          NonNull::without_provenance(self.align.as_nonzero())
      .               }
      .           
      .               /// Creates a layout describing the record that can hold a value
      .               /// of the same layout as `self`, but that also is aligned to
      .               /// alignment `align` (measured in bytes).
      .               ///
      .               /// If `self` already meets the prescribed alignment, then returns
      .               /// `self`.
-- line 244 ----------------------------------------

      1 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/mutex/futex.rs
--------------------------------------------------------------------------------
Ir               

-- line 10 ----------------------------------------
      .           
      .           const UNLOCKED: State = 0;
      .           const LOCKED: State = 1; // locked, no other threads waiting
      .           const CONTENDED: State = 2; // locked, and other threads waiting (contended)
      .           
      .           impl Mutex {
      .               #[inline]
      .               pub const fn new() -> Self {
      2 ( 0.00%)          Self { futex: Futex::new(UNLOCKED) }
      .               }
      .           
      .               #[inline]
      .               pub fn try_lock(&self) -> bool {
      .                   self.futex.compare_exchange(UNLOCKED, LOCKED, Acquire, Relaxed).is_ok()
      .               }
      .           
      .               #[inline]
      .               pub fn lock(&self) {
192,018 ( 0.16%)          if self.futex.compare_exchange(UNLOCKED, LOCKED, Acquire, Relaxed).is_err() {
      .                       self.lock_contended();
      .                   }
      .               }
      .           
      .               #[cold]
      .               fn lock_contended(&self) {
      .                   // Spin first to speed things up if the lock is released quickly.
      .                   let mut state = self.spin();
-- line 36 ----------------------------------------
-- line 76 ----------------------------------------
      .           
      .                       crate::hint::spin_loop();
      .                       spin -= 1;
      .                   }
      .               }
      .           
      .               #[inline]
      .               pub unsafe fn unlock(&self) {
128,012 ( 0.11%)          if self.futex.swap(UNLOCKED, Release) == CONTENDED {
      .                       // We only wake up one thread. When that thread locks the mutex, it
      .                       // will mark the mutex as CONTENDED (see lock_contended above),
      .                       // which makes sure that any other waiting threads will also be
      .                       // woken up eventually.
      .                       self.wake();
      .                   }
      .               }
      .           
-- line 92 ----------------------------------------

 32,003 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/mutex/futex.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: samples/multi_producer_sample.rs
--------------------------------------------------------------------------------
Ir                 

        .           use oxidator::client::DisruptorClient;
        .           use oxidator::traits::{Task, Sequence, WorkerHandle, Orchestrator, EventProducer};
        .           use oxidator::RingBuffer;
        .           use std::sync::{Arc, Mutex, atomic::{AtomicI32, Ordering}};
        .           use std::thread;
        .           
   67,072 ( 0.06%)  #[derive(Default, Debug, Clone)]
        .           struct Event {
   32,000 ( 0.03%)      value: i32,
   32,000 ( 0.03%)      producer_id: usize,
        .           }
        .           
        2 ( 0.00%)  #[derive(Clone)]
        .           struct PrinterTask;
        .           
        .           impl Task<Event> for PrinterTask {
  192,000 ( 0.16%)      fn execute_task(&self, event: &Event, sequence: Sequence, end_of_batch: bool) {
   32,000 ( 0.03%)      }
        .           
        2 ( 0.00%)      fn clone_box(&self) -> Box<dyn Task<Event> +Send + Sync + 'static> {
        4 ( 0.00%)          Box::new(self.clone())
        2 ( 0.00%)  => samples/multi_producer_sample.rs:<multi_producer::PrinterTask as core::clone::Clone>::clone (1x)
        3 ( 0.00%)      }
        .           }
        .           
        .           struct EventCounters {
        .               producer_events: [i32; 10],
        .               producer_count: usize,
        .               max_values: [i32; 10],
        .               producer_sums: [i64; 10],
        .           }
        .           
       12 ( 0.00%)  #[derive(Clone)]
        .           struct SumTask {
        6 ( 0.00%)      sum: Arc<AtomicI32>,
       60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
        8 ( 0.00%)      counters: Arc<Mutex<EventCounters>>,
       60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
        .           }
        .           
        .           impl SumTask {
        4 ( 0.00%)      fn new(num_producers: usize) -> Self {
        1 ( 0.00%)          Self {
       10 ( 0.00%)              sum: Arc::new(AtomicI32::new(0)),
      290 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T>::new (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI32::new (1x)
        5 ( 0.00%)              counters: Arc::new(Mutex::new(
      494 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T>::new (1x)
       86 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::Mutex<T>::new (1x)
       25 ( 0.00%)                  EventCounters { 
        5 ( 0.00%)                      producer_events: [0; 10], 
        .                               producer_count: num_producers, 
        3 ( 0.00%)                      max_values: [0; 10], 
        5 ( 0.00%)                      producer_sums: [0; 10] 
        .                           }
        .                       )),
        .                   }
        2 ( 0.00%)      }
        .           
        2 ( 0.00%)      fn get_sum(&self) -> i32 {
        5 ( 0.00%)          self.sum.load(Ordering::Relaxed)
       32 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI32::load (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
        2 ( 0.00%)      }
        .           
        7 ( 0.00%)      fn get_counters(&self) -> [i32; 10] {
        8 ( 0.00%)          let counters = self.counters.lock().unwrap();
      218 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::Mutex<T>::lock (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
        7 ( 0.00%)          counters.producer_events
       12 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref (1x)
        5 ( 0.00%)      }
       78 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::sync::poison::mutex::MutexGuard<multi_producer::EventCounters>> (1x)
        .               
        7 ( 0.00%)      fn get_max_values(&self) -> [i32; 10] {
        8 ( 0.00%)          let counters = self.counters.lock().unwrap();
      218 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::Mutex<T>::lock (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
        7 ( 0.00%)          counters.max_values
       12 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref (1x)
        5 ( 0.00%)      }
       78 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::sync::poison::mutex::MutexGuard<multi_producer::EventCounters>> (1x)
        .               
        7 ( 0.00%)      fn get_producer_sums(&self) -> [i64; 10] {
        8 ( 0.00%)          let counters = self.counters.lock().unwrap();
      218 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::Mutex<T>::lock (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
        6 ( 0.00%)          counters.producer_sums
       22 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref (1x)
        5 ( 0.00%)      }
       78 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::sync::poison::mutex::MutexGuard<multi_producer::EventCounters>> (1x)
        .           }
        .           
        .           impl Task<Event> for SumTask {
  288,000 ( 0.24%)      fn execute_task(&self, event: &Event, sequence: Sequence, end_of_batch: bool) {
  288,000 ( 0.24%)          self.sum.fetch_add(event.value, Ordering::Relaxed);
  704,000 ( 0.60%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI32::fetch_add (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
        .           
  256,000 ( 0.22%)          let mut counters = self.counters.lock().unwrap();
6,976,000 ( 5.90%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::Mutex<T>::lock (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
  128,000 ( 0.11%)          let producer_id = event.producer_id;
  192,000 ( 0.16%)          if producer_id < counters.producer_count {
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref (32,000x)
  384,000 ( 0.32%)              counters.producer_events[producer_id] += 1;
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::DerefMut>::deref_mut (32,000x)
  352,000 ( 0.30%)              if event.value > counters.max_values[producer_id] {
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::Deref>::deref (32,000x)
   29,952 ( 0.03%)                  counters.max_values[producer_id] = event.value;
   13,312 ( 0.01%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::DerefMut>::deref_mut (3,328x)
        .                       }
  448,000 ( 0.38%)              counters.producer_sums[producer_id] += event.value as i64;
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:<std::sync::poison::mutex::MutexGuard<T> as core::ops::deref::DerefMut>::deref_mut (32,000x)
        .                   }
  192,000 ( 0.16%)          drop(counters);
2,784,000 ( 2.36%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:core::mem::drop (32,000x)
   96,000 ( 0.08%)      }
        .           
        2 ( 0.00%)      fn clone_box(&self) -> Box<dyn Task<Event> + Send + Sync + 'static> {
        5 ( 0.00%)          Box::new(self.clone())
       74 ( 0.00%)  => samples/multi_producer_sample.rs:<multi_producer::SumTask as core::clone::Clone>::clone (1x)
        3 ( 0.00%)      }
        .           }
        .           
        .           
        1 ( 0.00%)  fn main() {
        4 ( 0.00%)      let buffer_size = 1024;
        1 ( 0.00%)      let num_producers = 4;
        1 ( 0.00%)      let events_per_producer = 8000;
        .           
       22 ( 0.00%)      println!("Starting multi-producer benchmark with {} producers, {} events each (total: {})",
    2,013 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (3x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (1x)
        8 ( 0.00%)          num_producers, events_per_producer, num_producers * events_per_producer);
        .           
       28 ( 0.00%)      let (producers, mut consumer_factory) = DisruptorClient
  142,197 ( 0.12%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::WaitStrategyLayer<T,D,W>::with_multi_producer (1x)
  124,777 ( 0.11%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::DisruptorClient::init_data_storage (1x)
    1,737 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::SequencerLayer<T,D,W,S>::build (1x)
       26 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::DataStorageLayer<T,D>::with_yielding_wait_strategy (1x)
        .                   .init_data_storage::<Event, RingBuffer<Event>>(buffer_size)
        .                   .with_yielding_wait_strategy()
        .                   .with_multi_producer()
        .                   .build::<PrinterTask>(num_producers);
        .           
        1 ( 0.00%)      let printer_task = Box::new(PrinterTask);
       17 ( 0.00%)      let printer_idx = consumer_factory.add_task(printer_task, vec![]);
    4,637 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::ConsumerFactory<T,D,W,S>::add_task (1x)
        7 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T>::new (1x)
        7 ( 0.00%)      let sum_task = Box::new(SumTask::new(num_producers));
      936 ( 0.00%)  => samples/multi_producer_sample.rs:multi_producer::SumTask::new (1x)
       38 ( 0.00%)      let sum_idx = consumer_factory.add_task(sum_task.clone(), vec![printer_idx]);
    5,501 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::ConsumerFactory<T,D,W,S>::add_task (1x)
      604 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:<alloc::boxed::Box<T,A> as core::clone::Clone>::clone (1x)
      401 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::exchange_malloc (1x)
       44 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:alloc::slice::<impl [T]>::into_vec (1x)
        .           
        2 ( 0.00%)      let consumers = consumer_factory.init_consumers();
   10,784 ( 0.01%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/client/client.rs:oxidator::client::client::ConsumerFactory<T,D,W,S>::init_consumers (1x)
        5 ( 0.00%)      let mut consumer_handle = consumers.start();
    9,823 ( 0.01%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/consumer/orchestrator.rs:<oxidator::consumer::orchestrator::ConsumerOrchestrator as oxidator::traits::traits::Orchestrator>::start (1x)
        .           
        4 ( 0.00%)      let mut producer_handles = vec![];
        7 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T>::new (1x)
        .           
       66 ( 0.00%)      for producer_id in 0..num_producers {
      229 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next (5x)
        5 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (1x)
       76 ( 0.00%)          let producer = producers[producer_id % producers.len()].clone();
      448 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index (4x)
      296 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/producer/producer.rs:<oxidator::producer::producer::Producer<T,S,D> as core::clone::Clone>::clone (4x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::len (4x)
        .                   
       44 ( 0.00%)          let handle = thread::spawn(move || {
   12,354 ( 0.01%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/mod.rs:std::thread::spawn (4x)
        4 ( 0.00%)              let mut sent_count = 0;
        .                       
  384,068 ( 0.33%)              for i in 0..events_per_producer {
1,664,084 ( 1.41%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next (32,004x)
       20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (4x)
  512,000 ( 0.43%)                  let event_val = (producer_id * events_per_producer + i + 1) as i32;
  128,000 ( 0.11%)                  let event = Event {
        .                               value: event_val,
   64,000 ( 0.05%)                      producer_id,
        .                           };
        .           
  928,000 ( 0.79%)                  producer.write(vec![event], |slot, seq, event| {
69,376,000 (58.71%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/producer/producer.rs:<oxidator::producer::producer::Producer<T,S,D> as oxidator::traits::traits::EventProducer>::write (32,000x)
8,288,552 ( 7.01%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::exchange_malloc (32,000x)
1,408,000 ( 1.19%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:alloc::slice::<impl [T]>::into_vec (32,000x)
  128,000 ( 0.11%)                      *slot = event.clone();
  128,000 ( 0.11%)  => samples/multi_producer_sample.rs:<multi_producer::Event as core::clone::Clone>::clone (32,000x)
   64,000 ( 0.05%)                  });
        .                           
  192,000 ( 0.16%)                  sent_count += 1;
        .                       }
       12 ( 0.00%)          });
      292 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<multi_producer::main::{{closure}}> (4x)
       28 ( 0.00%)          producer_handles.push(handle);
      517 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push (4x)
        .               }
        .           
       94 ( 0.00%)      for handle in producer_handles {
      216 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next (5x)
       56 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter (1x)
       28 ( 0.00%)          handle.join().unwrap();
    4,104 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/mod.rs:std::thread::JoinHandle<T>::join (4x)
        4 ( 0.00%)      }
      289 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::vec::into_iter::IntoIter<std::thread::JoinHandle<()>>> (1x)
        .           
        8 ( 0.00%)      println!("All producers finished, draining sequencer...");
      356 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_const (1x)
        9 ( 0.00%)      producers[0].drain();
      112 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index (1x)
       77 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/producer/producer.rs:<oxidator::producer::producer::Producer<T,S,D> as oxidator::traits::traits::EventProducer>::drain (1x)
        .           
        8 ( 0.00%)      println!("Waiting for consumers to finish...");
      356 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_const (1x)
        4 ( 0.00%)      consumer_handle.join();
    2,754 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/consumer/orchestrator.rs:<oxidator::consumer::orchestrator::ConsumerWorkerHandle as oxidator::traits::traits::WorkerHandle>::join (1x)
        .           
       12 ( 0.00%)      let final_sum = sum_task.get_sum();
       45 ( 0.00%)  => samples/multi_producer_sample.rs:multi_producer::SumTask::get_sum (1x)
        .           
       10 ( 0.00%)      let producer_counts = sum_task.get_counters();
      352 ( 0.00%)  => samples/multi_producer_sample.rs:multi_producer::SumTask::get_counters (1x)
       10 ( 0.00%)      let producer_max_values = sum_task.get_max_values();
      352 ( 0.00%)  => samples/multi_producer_sample.rs:multi_producer::SumTask::get_max_values (1x)
       10 ( 0.00%)      let producer_sums = sum_task.get_producer_sums();
      361 ( 0.00%)  => samples/multi_producer_sample.rs:multi_producer::SumTask::get_producer_sums (1x)
        .               
        1 ( 0.00%)      let mut total_processed = 0;
        1 ( 0.00%)      let mut total_expected_sum_calculated = 0i64;
        1 ( 0.00%)      let mut total_actual_sum_from_components = 0i64;
        .           
       57 ( 0.00%)      for producer_id in 0..num_producers {
      229 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next (5x)
        5 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (1x)
       20 ( 0.00%)          let actual_count = producer_counts[producer_id];
       28 ( 0.00%)          total_processed += actual_count;
        .           
       20 ( 0.00%)          let producer_actual_sum = producer_sums[producer_id];
       28 ( 0.00%)          total_actual_sum_from_components += producer_actual_sum;
        .           
       48 ( 0.00%)          let start_val = (producer_id * events_per_producer + 1) as i64;
       48 ( 0.00%)          let end_val = (producer_id * events_per_producer + events_per_producer) as i64;
        .           
       12 ( 0.00%)          let expected_producer_sum = if events_per_producer > 0 {
       92 ( 0.00%)               (events_per_producer as i64 * (start_val + end_val)) / 2
        .                   } else {
        .                       0
        .                   };
       36 ( 0.00%)          total_expected_sum_calculated += expected_producer_sum;
        .           
       84 ( 0.00%)          println!(
    7,754 ( 0.01%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (4x)
      120 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (12x)
       48 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (4x)
        .                       "Producer {} | actual events processed: {} | expected events produced: {}",
        .                       producer_id,
        .                       actual_count,
        .                       events_per_producer
        .                   );
        .           
       88 ( 0.00%)          println!(
    8,818 ( 0.01%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (4x)
      120 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (12x)
       48 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (4x)
        .                       "    Expected sum for generated events: {}, Actual tracked sum by consumer: {}, Difference: {}",
        .                       expected_producer_sum, producer_actual_sum,
       44 ( 0.00%)              (expected_producer_sum - producer_actual_sum).abs()
       72 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:core::num::<impl i64>::abs (4x)
        .                   );
        .           
        .                   // assert_eq!(actual_count as usize, events_per_producer, "Producer {} event count mismatch", producer_id);
        .                   // assert_eq!(producer_actual_sum, expected_producer_sum, "Producer {} sum mismatch", producer_id);
        .               }
        .           
        7 ( 0.00%)      let total_expected = num_producers * events_per_producer;
       13 ( 0.00%)      let completion_percentage = (total_processed as f64 / total_expected as f64) * 100.0;
        .           
        8 ( 0.00%)      println!("All producers and consumers have completed:");
      356 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_const (1x)
       13 ( 0.00%)      println!("  Final tracked sum (Atomic): {}", final_sum);
    1,035 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       10 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (1x)
       13 ( 0.00%)      println!("  Expected sum (Calculated from producer ranges): {}", total_expected_sum_calculated);
    1,082 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       10 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (1x)
       13 ( 0.00%)      println!("  Sum from individual producer tracking (Mutex): {}", total_actual_sum_from_components);
    1,077 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       10 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (1x)
       13 ( 0.00%)      println!("  Total events processed by SumTask: {}", total_processed);
      943 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       10 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (1x)
       13 ( 0.00%)      println!("  Total events expected: {}", total_expected);
      945 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       10 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1 (1x)
       47 ( 0.00%)      println!("  Completion percentage: {:.2}%", completion_percentage);
    2,742 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       10 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (1x)
       26 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Placeholder::new (1x)
       20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1_formatted (1x)
        1 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::UnsafeArg::new (1x)
        .           
        .               // assert!(completion_percentage >= 99.99,
        .               //     "Total processed events count too low: {}/{} ({:.2}%)",
        .               //     total_processed, total_expected, completion_percentage);
        .           
        9 ( 0.00%)      let sum_difference = (final_sum as i64 - total_expected_sum_calculated).abs();
       11 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:core::num::<impl i64>::abs (1x)
        2 ( 0.00%)      let tolerance_percentage = if total_expected_sum_calculated > 0 {
        6 ( 0.00%)          (sum_difference as f64 / total_expected_sum_calculated as f64) * 100.0
        .               } else {
        .                   0.0
        .               };
        .           
        9 ( 0.00%)      let component_difference = (final_sum as i64 - total_actual_sum_from_components).abs();
       11 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:core::num::<impl i64>::abs (1x)
        2 ( 0.00%)      let component_tolerance = if total_actual_sum_from_components > 0 {
        6 ( 0.00%)          (component_difference as f64 / total_actual_sum_from_components as f64) * 100.0
        .               } else {
        .                   0.0
        .               };
        .           
        2 ( 0.00%)      let tolerance_threshold = 0.01;
        .           
        8 ( 0.00%)      println!("Verification metrics:");
      356 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_const (1x)
       77 ( 0.00%)      println!("  Expected sum vs final atomic sum difference: {} ({:.2}%)", sum_difference, tolerance_percentage);
    2,278 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (2x)
       52 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Placeholder::new (2x)
       20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1_formatted (1x)
        1 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::UnsafeArg::new (1x)
       77 ( 0.00%)      println!("  Final atomic sum vs component sum (Mutex) difference: {} ({:.2}%)", component_difference, component_tolerance);
    1,635 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Argument::new_display (2x)
       52 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::Placeholder::new (2x)
       20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_v1_formatted (1x)
        1 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/rt.rs:core::fmt::rt::UnsafeArg::new (1x)
        .           
        .               // assert!(tolerance_percentage <= tolerance_threshold,
        .               //     "Sum difference (Atomic vs Expected) too large: {} ({:.2}%)", sum_difference, tolerance_percentage);
        .           
        .               // assert!(component_tolerance <= tolerance_threshold,
        .               //     "Component tracking inconsistency detected (Atomic vs Mutex): {} ({:.2}%)",
        .               //     component_difference, component_tolerance);
        .           
        8 ( 0.00%)      println!("\nVerification successful!");
      356 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/io/stdio.rs:std::io::stdio::_print (1x)
       12 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:core::fmt::Arguments::new_const (1x)
       12 ( 0.00%)  }
    2,607 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::vec::Vec<oxidator::producer::producer::Producer<multi_producer::Event,oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>,oxidator::storage::ring_buffer::RingBuffer<multi_producer::Event>>>> (1x)
    1,931 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<oxidator::client::client::ConsumerFactory<multi_producer::Event,oxidator::storage::ring_buffer::RingBuffer<multi_producer::Event>,oxidator::coordinator::wait::YieldingWaitStrategy,oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>>> (1x)
      412 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<oxidator::consumer::orchestrator::ConsumerWorkerHandle> (1x)
      259 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::boxed::Box<multi_producer::SumTask>> (1x)

1,585,978 ( 1.34%)  <counts for unidentified lines in samples/multi_producer_sample.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/manually_drop.rs
--------------------------------------------------------------------------------
Ir               

-- line 173 ----------------------------------------
      .               /// # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.
      .               /// # let _ = ManuallyDrop::into_inner(x);
      .               /// ```
      .               #[must_use = "if you don't need the wrapper, you can use `mem::forget` instead"]
      .               #[stable(feature = "manually_drop", since = "1.20.0")]
      .               #[rustc_const_stable(feature = "const_manually_drop", since = "1.32.0")]
      .               #[inline(always)]
      .               pub const fn new(value: T) -> ManuallyDrop<T> {
192,122 ( 0.16%)          ManuallyDrop { value }
     72 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (6x)
      .               }
      .           
      .               /// Extracts the value from the `ManuallyDrop` container.
      .               ///
      .               /// This allows the value to be dropped again.
      .               ///
      .               /// # Examples
      .               ///
-- line 189 ----------------------------------------
-- line 257 ----------------------------------------
      .               }
      .           }
      .           
      .           #[stable(feature = "manually_drop", since = "1.20.0")]
      .           impl<T: ?Sized> Deref for ManuallyDrop<T> {
      .               type Target = T;
      .               #[inline(always)]
      .               fn deref(&self) -> &T {
128,016 ( 0.11%)          &self.value
      .               }
      .           }
      .           
      .           #[stable(feature = "manually_drop", since = "1.20.0")]
      .           impl<T: ?Sized> DerefMut for ManuallyDrop<T> {
      .               #[inline(always)]
      .               fn deref_mut(&mut self) -> &mut T {
      .                   &mut self.value
-- line 273 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs
--------------------------------------------------------------------------------
Ir               

-- line 600 ----------------------------------------
      .               /// let x: Option<u32> = None;
      .               /// assert_eq!(x.is_some(), false);
      .               /// ```
      .               #[must_use = "if you intended to assert that this has a value, consider `.unwrap()` instead"]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
      .               pub const fn is_some(&self) -> bool {
      2 ( 0.00%)          matches!(*self, Some(_))
      .               }
      .           
      .               /// Returns `true` if the option is a [`Some`] and the value inside of it matches a predicate.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// let x: Option<u32> = Some(2);
-- line 616 ----------------------------------------
-- line 644 ----------------------------------------
      .               /// assert_eq!(x.is_none(), true);
      .               /// ```
      .               #[must_use = "if you intended to assert that this doesn't have a value, consider \
      .                             wrapping this in an `assert!()` instead"]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_option_basics", since = "1.48.0")]
      .               pub const fn is_none(&self) -> bool {
      8 ( 0.00%)          !self.is_some()
      .               }
      .           
      .               /// Returns `true` if the option is a [`None`] or the value inside of it matches a predicate.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// let x: Option<u32> = Some(2);
-- line 660 ----------------------------------------
-- line 968 ----------------------------------------
      .               /// ```
      .               #[inline(always)]
      .               #[track_caller]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "option_unwrap")]
      .               #[rustc_allow_const_fn_unstable(const_precise_live_drops)]
      .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
      .               pub const fn unwrap(self) -> T {
     24 ( 0.00%)          match self {
     58 ( 0.00%)              Some(val) => val,
      .                       None => unwrap_failed(),
      .                   }
      .               }
      .           
      .               /// Returns the contained [`Some`] value or a provided default.
      .               ///
      .               /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing
      .               /// the result of a function call, it is recommended to use [`unwrap_or_else`],
-- line 985 ----------------------------------------
-- line 990 ----------------------------------------
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// assert_eq!(Some("car").unwrap_or("bike"), "car");
      .               /// assert_eq!(None.unwrap_or("bike"), "bike");
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
     12 ( 0.00%)      pub fn unwrap_or(self, default: T) -> T {
     15 ( 0.00%)          match self {
      6 ( 0.00%)              Some(x) => x,
      2 ( 0.00%)              None => default,
      .                   }
      4 ( 0.00%)      }
      .           
      .               /// Returns the contained [`Some`] value or computes it from a closure.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// let k = 10;
      .               /// assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);
-- line 1011 ----------------------------------------
-- line 1013 ----------------------------------------
      .               /// ```
      .               #[inline]
      .               #[track_caller]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub fn unwrap_or_else<F>(self, f: F) -> T
      .               where
      .                   F: FnOnce() -> T,
      .               {
     13 ( 0.00%)          match self {
      .                       Some(x) => x,
     26 ( 0.00%)              None => f(),
    119 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:core::ops::function::FnOnce::call_once'2 (1x)
      .                   }
      .               }
      .           
      .               /// Returns the contained [`Some`] value or a default.
      .               ///
      .               /// Consumes the `self` argument then, if [`Some`], returns the contained
      .               /// value, otherwise if [`None`], returns the [default value] for that
      .               /// type.
-- line 1031 ----------------------------------------
-- line 1040 ----------------------------------------
      .               /// assert_eq!(y.unwrap_or_default(), 12);
      .               /// ```
      .               ///
      .               /// [default value]: Default::default
      .               /// [`parse`]: str::parse
      .               /// [`FromStr`]: crate::str::FromStr
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
    642 ( 0.00%)      pub fn unwrap_or_default(self) -> T
      .               where
      .                   T: Default,
      .               {
    642 ( 0.00%)          match self {
    963 ( 0.00%)              Some(x) => x,
      .                       None => T::default(),
      .                   }
    642 ( 0.00%)      }
      .           
      .               /// Returns the contained [`Some`] value, consuming the `self` value,
      .               /// without checking that the value is not [`None`].
      .               ///
      .               /// # Safety
      .               ///
      .               /// Calling this method on [`None`] is *[undefined behavior]*.
      .               ///
-- line 1064 ----------------------------------------
-- line 1076 ----------------------------------------
      .               /// assert_eq!(unsafe { x.unwrap_unchecked() }, "air"); // Undefined behavior!
      .               /// ```
      .               #[inline]
      .               #[track_caller]
      .               #[stable(feature = "option_result_unwrap_unchecked", since = "1.58.0")]
      .               #[rustc_allow_const_fn_unstable(const_precise_live_drops)]
      .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
      .               pub const unsafe fn unwrap_unchecked(self) -> T {
      4 ( 0.00%)          match self {
127,988 ( 0.11%)              Some(val) => val,
      .                       // SAFETY: the safety contract must be upheld by the caller.
      .                       None => unsafe { hint::unreachable_unchecked() },
      .                   }
      .               }
      .           
      .               /////////////////////////////////////////////////////////////////////////
      .               // Transforming contained values
      .               /////////////////////////////////////////////////////////////////////////
-- line 1093 ----------------------------------------
-- line 1110 ----------------------------------------
      .               /// assert_eq!(x.map(|s| s.len()), None);
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub fn map<U, F>(self, f: F) -> Option<U>
      .               where
      .                   F: FnOnce(T) -> U,
      .               {
  2,247 ( 0.00%)          match self {
  1,605 ( 0.00%)              Some(x) => Some(f(x)),
 19,581 ( 0.02%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &mut F>::call_once (321x)
      .                       None => None,
      .                   }
      .               }
      .           
      .               /// Calls a function with a reference to the contained value if [`Some`].
      .               ///
      .               /// Returns the original option.
      .               ///
-- line 1127 ----------------------------------------
-- line 1246 ----------------------------------------
      .               ///
      .               /// let x: Option<&str> = None;
      .               /// assert_eq!(x.ok_or(0), Err(0));
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub fn ok_or<E>(self, err: E) -> Result<T, E> {
      .                   match self {
 96,090 ( 0.08%)              Some(v) => Ok(v),
      .                       None => Err(err),
      .                   }
      .               }
      .           
      .               /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to
      .               /// [`Ok(v)`] and [`None`] to [`Err(err())`].
      .               ///
      .               /// [`Ok(v)`]: Ok
-- line 1262 ----------------------------------------
-- line 1273 ----------------------------------------
      .               /// assert_eq!(x.ok_or_else(|| 0), Err(0));
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>
      .               where
      .                   F: FnOnce() -> E,
      .               {
      3 ( 0.00%)          match self {
      5 ( 0.00%)              Some(v) => Ok(v),
      .                       None => Err(err()),
      .                   }
      .               }
      .           
      .               /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.
      .               ///
      .               /// Leaves the original Option in-place, creating a new one with a reference
      .               /// to the original one, additionally coercing the contents via [`Deref`].
-- line 1290 ----------------------------------------
-- line 1443 ----------------------------------------
      .               #[doc(alias = "flatmap")]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_confusables("flat_map", "flatmap")]
      .               pub fn and_then<U, F>(self, f: F) -> Option<U>
      .               where
      .                   F: FnOnce(T) -> Option<U>,
      .               {
     14 ( 0.00%)          match self {
      .                       Some(x) => f(x),
      5 ( 0.00%)              None => None,
      .                   }
      .               }
      .           
      .               /// Returns [`None`] if the option is [`None`], otherwise calls `predicate`
      .               /// with the wrapped value and returns:
      .               ///
      .               /// - [`Some(t)`] if `predicate` returns `true` (where `t` is the wrapped
      .               ///   value), and
-- line 1461 ----------------------------------------
-- line 1720 ----------------------------------------
      .               /// assert_eq!(x, None);
      .               /// assert_eq!(y, None);
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_option", since = "1.83.0")]
      .               pub const fn take(&mut self) -> Option<T> {
      .                   // FIXME(const-hack) replace `mem::replace` by `mem::take` when the latter is const ready
      6 ( 0.00%)          mem::replace(self, None)
      .               }
      .           
      .               /// Takes the value out of the option, but only if the predicate evaluates to
      .               /// `true` on a mutable reference to the value.
      .               ///
      .               /// In other words, replaces `self` with `None` if the predicate returns `true`.
      .               /// This method operates similar to [`Option::take`] but conditional.
      .               ///
-- line 1736 ----------------------------------------
-- line 2181 ----------------------------------------
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T> crate::marker::StructuralPartialEq for Option<T> {}
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: PartialEq> PartialEq for Option<T> {
      .               #[inline]
      .               fn eq(&self, other: &Self) -> bool {
      .                   // Spelling out the cases explicitly optimizes better than
      .                   // `_ => false`
320,020 ( 0.27%)          match (self, other) {
384,024 ( 0.32%)              (Some(l), Some(r)) => *l == *r,
      .                       (Some(_), None) => false,
      .                       (None, Some(_)) => false,
      .                       (None, None) => true,
      .                   }
 64,004 ( 0.05%)      }
      .           }
      .           
      .           // Manually implementing here somewhat improves codegen for
      .           // https://github.com/rust-lang/rust/issues/49892, although still
      .           // not optimal.
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: PartialOrd> PartialOrd for Option<T> {
      .               #[inline]
-- line 2203 ----------------------------------------
-- line 2479 ----------------------------------------
      .           
      .               #[inline]
      .               fn from_output(output: Self::Output) -> Self {
      .                   Some(output)
      .               }
      .           
      .               #[inline]
      .               fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
128,663 ( 0.11%)          match self {
225,324 ( 0.19%)              Some(v) => ControlFlow::Continue(v),
      .                       None => ControlFlow::Break(None),
      .                   }
      .               }
      .           }
      .           
      .           #[unstable(feature = "try_trait_v2", issue = "84277")]
      .           // Note: manually specifying the residual type instead of using the default to work around
      .           // https://github.com/rust-lang/rust/issues/99940
      .           impl<T> ops::FromResidual<Option<convert::Infallible>> for Option<T> {
      .               #[inline]
      .               fn from_residual(residual: Option<convert::Infallible>) -> Self {
      .                   match residual {
 32,001 ( 0.03%)              None => None,
      .                   }
      .               }
      .           }
      .           
      .           #[diagnostic::do_not_recommend]
      .           #[unstable(feature = "try_trait_v2_yeet", issue = "96374")]
      .           impl<T> ops::FromResidual<ops::Yeet<()>> for Option<T> {
      .               #[inline]
-- line 2509 ----------------------------------------

 32,351 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs
--------------------------------------------------------------------------------
Ir               

-- line 536 ----------------------------------------
      .               /// let five = c.get();
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_unstable(feature = "const_cell", issue = "131283")]
      .               pub const fn get(&self) -> T {
      .                   // SAFETY: This can cause data races if called from a separate thread,
      .                   // but `Cell` is `!Sync` so this won't happen.
      2 ( 0.00%)          unsafe { *self.value.get() }
      .               }
      .           
      .               /// Updates the contained value using a function and returns the new value.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// #![feature(cell_update)]
-- line 552 ----------------------------------------
-- line 2091 ----------------------------------------
      .               /// use std::cell::UnsafeCell;
      .               ///
      .               /// let uc = UnsafeCell::new(5);
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_unsafe_cell_new", since = "1.32.0")]
      .               #[inline(always)]
      .               pub const fn new(value: T) -> UnsafeCell<T> {
     28 ( 0.00%)          UnsafeCell { value }
     30 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
      .               }
      .           
      .               /// Unwraps the value, consuming the cell.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// use std::cell::UnsafeCell;
-- line 2107 ----------------------------------------
-- line 2190 ----------------------------------------
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_unsafecell_get", since = "1.32.0")]
      .               #[rustc_as_ptr]
      .               #[rustc_never_returns_null_ptr]
      .               pub const fn get(&self) -> *mut T {
      .                   // We can just cast the pointer from `UnsafeCell<T>` to `T` because of
      .                   // #[repr(transparent)]. This exploits std's special status, there is
      .                   // no guarantee for user code that this will work in future versions of the compiler!
227,650 ( 0.19%)          self as *const UnsafeCell<T> as *const T as *mut T
      .               }
      .           
      .               /// Returns a mutable reference to the underlying data.
      .               ///
      .               /// This call borrows the `UnsafeCell` mutably (at compile-time) which
      .               /// guarantees that we possess the only reference.
      .               ///
      .               /// # Examples
-- line 2206 ----------------------------------------
-- line 2212 ----------------------------------------
      .               /// *c.get_mut() += 1;
      .               ///
      .               /// assert_eq!(*c.get_mut(), 6);
      .               /// ```
      .               #[inline(always)]
      .               #[stable(feature = "unsafe_cell_get_mut", since = "1.50.0")]
      .               #[rustc_const_stable(feature = "const_unsafecell_get_mut", since = "1.83.0")]
      .               pub const fn get_mut(&mut self) -> &mut T {
     18 ( 0.00%)          &mut self.value
      .               }
      .           
      .               /// Gets a mutable pointer to the wrapped value.
      .               /// The difference from [`get`] is that this function accepts a raw pointer,
      .               /// which is useful to avoid the creation of temporary references.
      .               ///
      .               /// The result can be cast to a pointer of any kind.
      .               /// Ensure that the access is unique (no active references, mutable or not)
-- line 2228 ----------------------------------------

      1 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs
--------------------------------------------------------------------------------
Ir               

-- line 16 ----------------------------------------
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[cfg_attr(not(test), rustc_diagnostic_item = "Enumerate")]
      .           pub struct Enumerate<I> {
      .               iter: I,
      .               count: usize,
      .           }
      .           impl<I> Enumerate<I> {
      .               pub(in crate::iter) fn new(iter: I) -> Enumerate<I> {
288,013 ( 0.24%)          Enumerate { iter, count: 0 }
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<I> Iterator for Enumerate<I>
      .           where
      .               I: Iterator,
      .           {
-- line 32 ----------------------------------------
-- line 38 ----------------------------------------
      .               /// `usize::MAX` elements either produces the wrong result or panics. If
      .               /// debug assertions are enabled, a panic is guaranteed.
      .               ///
      .               /// # Panics
      .               ///
      .               /// Might panic if the index of the element overflows a `usize`.
      .               #[inline]
      .               #[rustc_inherit_overflow_checks]
320,009 ( 0.27%)      fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {
384,014 ( 0.32%)          let a = self.iter.next()?;
2,048,000 ( 1.73%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::next (64,000x)
     93 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:<core::slice::iter::Iter<T> as core::iter::traits::iterator::Iterator>::next (3x)
 96,006 ( 0.08%)          let i = self.count;
224,014 ( 0.19%)          self.count += 1;
320,004 ( 0.27%)          Some((i, a))
192,015 ( 0.16%)      }
      .           
      .               #[inline]
      .               fn size_hint(&self) -> (usize, Option<usize>) {
      .                   self.iter.size_hint()
      .               }
      .           
      .               #[inline]
      .               #[rustc_inherit_overflow_checks]
-- line 59 ----------------------------------------

288,010 ( 0.24%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs
--------------------------------------------------------------------------------
Ir               

-- line 40 ----------------------------------------
      .               }
      .           
      .               /// Casts to a pointer of another type.
      .               #[stable(feature = "ptr_cast", since = "1.38.0")]
      .               #[rustc_const_stable(feature = "const_ptr_cast", since = "1.38.0")]
      .               #[rustc_diagnostic_item = "ptr_cast"]
      .               #[inline(always)]
      .               pub const fn cast<U>(self) -> *mut U {
 32,331 ( 0.03%)          self as _
      .               }
      .           
      .               /// Uses the address value in a new pointer of another type.
      .               ///
      .               /// This operation will ignore the address part of its `meta` operand and discard existing
      .               /// metadata of `self`. For pointers to a sized types (thin pointers), this has the same effect
      .               /// as a simple cast. For pointers to an unsized type (fat pointers) this recombines the address
      .               /// with new metadata such as slice lengths or `dyn`-vtable.
-- line 56 ----------------------------------------
-- line 116 ----------------------------------------
      .               /// coercion.
      .               ///
      .               /// [`cast_mut`]: pointer::cast_mut
      .               #[stable(feature = "ptr_const_cast", since = "1.65.0")]
      .               #[rustc_const_stable(feature = "ptr_const_cast", since = "1.65.0")]
      .               #[rustc_diagnostic_item = "ptr_cast_const"]
      .               #[inline(always)]
      .               pub const fn cast_const(self) -> *const T {
    328 ( 0.00%)          self as _
      .               }
      .           
      .               /// Gets the "address" portion of the pointer.
      .               ///
      .               /// This is similar to `self as usize`, except that the [provenance][crate::ptr#provenance] of
      .               /// the pointer is discarded and not [exposed][crate::ptr#exposed-provenance]. This means that
      .               /// casting the returned address back to a pointer yields a [pointer without
      .               /// provenance][without_provenance_mut], which is undefined behavior to dereference. To properly
-- line 132 ----------------------------------------
-- line 944 ----------------------------------------
      .               #[rustc_const_unstable(feature = "const_ptr_sub_ptr", issue = "95892")]
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .               pub const unsafe fn sub_ptr(self, origin: *const T) -> usize
      .               where
      .                   T: Sized,
      .               {
      .                   // SAFETY: the caller must uphold the safety contract for `sub_ptr`.
 64,305 ( 0.05%)          unsafe { (self as *const T).sub_ptr(origin) }
      .               }
      .           
      .               /// Calculates the distance between two pointers within the same allocation, *where it's known that
      .               /// `self` is equal to or greater than `origin`*. The returned value is in
      .               /// units of **bytes**.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
      .               /// using [`sub_ptr`][pointer::sub_ptr] on it. See that method for
-- line 960 ----------------------------------------
-- line 1049 ----------------------------------------
      .                       (
      .                           this: *const () = self as *const (),
      .                           count: usize = count,
      .                           size: usize = size_of::<T>(),
      .                       ) => runtime_add_nowrap(this, count, size)
      .                   );
      .           
      .                   // SAFETY: the caller must uphold the safety contract for `offset`.
 68,862 ( 0.06%)          unsafe { intrinsics::offset(self, count) }
      .               }
      .           
      .               /// Adds an unsigned offset in bytes to a pointer.
      .               ///
      .               /// `count` is in units of bytes.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
      .               /// using [add][pointer::add] on it. See that method for documentation
-- line 1065 ----------------------------------------
-- line 1121 ----------------------------------------
      .               ///     assert_eq!('2', *end.sub(2) as char);
      .               /// }
      .               /// ```
      .               #[stable(feature = "pointer_methods", since = "1.26.0")]
      .               #[must_use = "returns a new pointer rather than modifying its argument"]
      .               #[rustc_const_stable(feature = "const_ptr_offset", since = "1.61.0")]
      .               #[inline(always)]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
     14 ( 0.00%)      pub const unsafe fn sub(self, count: usize) -> Self
      .               where
      .                   T: Sized,
      .               {
      .                   #[cfg(debug_assertions)]
      .                   #[inline]
      .                   #[rustc_allow_const_fn_unstable(const_eval_select)]
      .                   const fn runtime_sub_nowrap(this: *const (), count: usize, size: usize) -> bool {
      .                       const_eval_select!(
-- line 1137 ----------------------------------------
-- line 1153 ----------------------------------------
      .                       "ptr::sub requires that the address calculation does not overflow",
      .                       (
      .                           this: *const () = self as *const (),
      .                           count: usize = count,
      .                           size: usize = size_of::<T>(),
      .                       ) => runtime_sub_nowrap(this, count, size)
      .                   );
      .           
      5 ( 0.00%)          if T::IS_ZST {
      .                       // Pointer arithmetic does nothing when the pointee is a ZST.
      .                       self
      .                   } else {
      .                       // SAFETY: the caller must uphold the safety contract for `offset`.
      .                       // Because the pointee is *not* a ZST, that means that `count` is
      .                       // at most `isize::MAX`, and thus the negation cannot overflow.
     75 ( 0.00%)              unsafe { intrinsics::offset(self, intrinsics::unchecked_sub(0, count as isize)) }
      .                   }
      .               }
      .           
      .               /// Subtracts an unsigned offset in bytes from a pointer.
      .               ///
      .               /// `count` is in units of bytes.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
-- line 1176 ----------------------------------------
-- line 1484 ----------------------------------------
      .               ///
      .               /// See [`ptr::drop_in_place`] for safety concerns and examples.
      .               ///
      .               /// [`ptr::drop_in_place`]: crate::ptr::drop_in_place()
      .               #[stable(feature = "pointer_methods", since = "1.26.0")]
      .               #[inline(always)]
      .               pub unsafe fn drop_in_place(self) {
      .                   // SAFETY: the caller must uphold the safety contract for `drop_in_place`.
      4 ( 0.00%)          unsafe { drop_in_place(self) }
    193 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<(usize,alloc::vec::Vec<usize>)> (2x)
      .               }
      .           
      .               /// Overwrites a memory location with the given value without reading or
      .               /// dropping the old value.
      .               ///
      .               /// See [`ptr::write`] for safety concerns and examples.
      .               ///
      .               /// [`ptr::write`]: crate::ptr::write()
-- line 1500 ----------------------------------------
-- line 1516 ----------------------------------------
      .               /// See [`ptr::write_bytes`] for safety concerns and examples.
      .               ///
      .               /// [`ptr::write_bytes`]: crate::ptr::write_bytes()
      .               #[doc(alias = "memset")]
      .               #[stable(feature = "pointer_methods", since = "1.26.0")]
      .               #[rustc_const_stable(feature = "const_ptr_write", since = "1.83.0")]
      .               #[inline(always)]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      1 ( 0.00%)      pub const unsafe fn write_bytes(self, val: u8, count: usize)
      .               where
      .                   T: Sized,
      .               {
      .                   // SAFETY: the caller must uphold the safety contract for `write_bytes`.
      .                   unsafe { write_bytes(self, val, count) }
      .               }
      .           
      .               /// Performs a volatile write of a memory location with the given value without
-- line 1532 ----------------------------------------

160,623 ( 0.14%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs
--------------------------------------------------------------------------------
Ir               

-- line 38 ----------------------------------------
      .           ///
      .           /// This type implements the [`Allocator`] trait by forwarding calls
      .           /// to the allocator registered with the `#[global_allocator]` attribute
      .           /// if there is one, or the `std` crates default.
      .           ///
      .           /// Note: while this type is unstable, the functionality it provides can be
      .           /// accessed through the [free functions in `alloc`](self#functions).
      .           #[unstable(feature = "allocator_api", issue = "32838")]
     84 ( 0.00%)  #[derive(Copy, Clone, Default, Debug)]
      .           #[cfg(not(test))]
      .           // the compiler needs to know when a Box uses the global allocator vs a custom one
      .           #[lang = "global_alloc_ty"]
      .           pub struct Global;
      .           
      .           #[cfg(test)]
      .           pub use std::alloc::Global;
      .           
-- line 54 ----------------------------------------
-- line 82 ----------------------------------------
      .           ///
      .           ///     dealloc(ptr, layout);
      .           /// }
      .           /// ```
      .           #[stable(feature = "global_alloc", since = "1.28.0")]
      .           #[must_use = "losing the pointer will leak memory"]
      .           #[inline]
      .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
 96,087 ( 0.08%)  pub unsafe fn alloc(layout: Layout) -> *mut u8 {
      .               unsafe {
      .                   // Make sure we don't accidentally allow omitting the allocator shim in
      .                   // stable code until it is actually stabilized.
      .                   core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);
      .           
160,145 ( 0.14%)          __rust_alloc(layout.size(), layout.align())
1,765,640 ( 1.49%)  => ???:__rust_alloc (32,029x)
      .               }
 64,058 ( 0.05%)  }
      .           
      .           /// Deallocates memory with the global allocator.
      .           ///
      .           /// This function forwards calls to the [`GlobalAlloc::dealloc`] method
      .           /// of the allocator registered with the `#[global_allocator]` attribute
      .           /// if there is one, or the `std` crates default.
      .           ///
      .           /// This function is expected to be deprecated in favor of the `deallocate` method
-- line 106 ----------------------------------------
-- line 108 ----------------------------------------
      .           ///
      .           /// # Safety
      .           ///
      .           /// See [`GlobalAlloc::dealloc`].
      .           #[stable(feature = "global_alloc", since = "1.28.0")]
      .           #[inline]
      .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .           pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
    110 ( 0.00%)      unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }
  2,098 ( 0.00%)  => ???:__rust_dealloc (22x)
      .           }
      .           
      .           /// Reallocates memory with the global allocator.
      .           ///
      .           /// This function forwards calls to the [`GlobalAlloc::realloc`] method
      .           /// of the allocator registered with the `#[global_allocator]` attribute
      .           /// if there is one, or the `std` crates default.
      .           ///
-- line 124 ----------------------------------------
-- line 179 ----------------------------------------
      .                   __rust_alloc_zeroed(layout.size(), layout.align())
      .               }
      .           }
      .           
      .           #[cfg(not(test))]
      .           impl Global {
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
256,248 ( 0.22%)      fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {
128,124 ( 0.11%)          match layout.size() {
      8 ( 0.00%)              0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
      .                       // SAFETY: `layout` is non-zero in size,
      .                       size => unsafe {
256,232 ( 0.22%)                  let raw_ptr = if zeroed { alloc_zeroed(layout) } else { alloc(layout) };
4,167,815 ( 3.53%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::alloc (32,029x)
192,174 ( 0.16%)                  let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
 64,058 ( 0.05%)                  Ok(NonNull::slice_from_raw_parts(ptr, size))
 32,029 ( 0.03%)              },
      .                   }
128,124 ( 0.11%)      }
      .           
      .               // SAFETY: Same as `Allocator::grow`
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .               unsafe fn grow_impl(
      .                   &self,
      .                   ptr: NonNull<u8>,
      .                   old_layout: Layout,
-- line 205 ----------------------------------------
-- line 245 ----------------------------------------
      .               }
      .           }
      .           
      .           #[unstable(feature = "allocator_api", issue = "32838")]
      .           #[cfg(not(test))]
      .           unsafe impl Allocator for Global {
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
 64,068 ( 0.05%)      fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
160,147 ( 0.14%)          self.alloc_impl(layout, false)
6,473,304 ( 5.48%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::Global::alloc_impl (32,029x)
      4 ( 0.00%)      }
      .           
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .               fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
      .                   self.alloc_impl(layout, true)
      .               }
      .           
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
    132 ( 0.00%)      unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
    110 ( 0.00%)          if layout.size() != 0 {
      .                       // SAFETY: `layout` is non-zero in size,
      .                       // other conditions must be upheld by the caller
     88 ( 0.00%)              unsafe { dealloc(ptr.as_ptr(), layout) }
      .                   }
     44 ( 0.00%)      }
      .           
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .               unsafe fn grow(
      .                   &self,
      .                   ptr: NonNull<u8>,
      .                   old_layout: Layout,
      .                   new_layout: Layout,
-- line 279 ----------------------------------------
-- line 339 ----------------------------------------
      .               }
      .           }
      .           
      .           /// The allocator for `Box`.
      .           #[cfg(all(not(no_global_oom_handling), not(test)))]
      .           #[lang = "exchange_malloc"]
      .           #[inline]
      .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
160,145 ( 0.14%)  unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {
      .               let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
224,203 ( 0.19%)      match Global.allocate(layout) {
128,116 ( 0.11%)          Ok(ptr) => ptr.as_mut_ptr(),
      .                   Err(_) => handle_alloc_error(layout),
      .               }
 64,058 ( 0.05%)  }
      .           
      .           // # Allocation error handler
      .           
      .           #[cfg(not(no_global_oom_handling))]
      .           unsafe extern "Rust" {
      .               // This is the magic symbol to call the global alloc error handler. rustc generates
      .               // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the
      .               // default implementations below (`__rdl_oom`) otherwise.
-- line 361 ----------------------------------------

 64,104 ( 0.05%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs
--------------------------------------------------------------------------------
Ir                 

-- line 76 ----------------------------------------
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
        .                   #[doc(alias = "popcount")]
        .                   #[doc(alias = "popcnt")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        6 ( 0.00%)          pub const fn count_ones(self) -> u32 {
4,481,600 ( 3.79%)              return intrinsics::ctpop(self);
        .                   }
        .           
        .                   /// Returns the number of zeros in the binary representation of `self`.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
        .                   ///
-- line 93 ----------------------------------------
-- line 252 ----------------------------------------
        .                   ///
        .                   #[doc = concat!("assert_eq!(n.rotate_left(", $rot, "), m);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
      150 ( 0.00%)          pub const fn rotate_left(self, n: u32) -> Self {
      450 ( 0.00%)              return intrinsics::rotate_left(self, n);
        .                   }
        .           
        .                   /// Shifts the bits to the right by a specified amount, `n`,
        .                   /// wrapping the truncated bits to the beginning of the resulting
        .                   /// integer.
        .                   ///
        .                   /// Please note this isn't the same operation as the `>>` shifting operator!
        .                   ///
-- line 269 ----------------------------------------
-- line 486 ----------------------------------------
        .                   pub const fn checked_add(self, rhs: Self) -> Option<Self> {
        .                       // This used to use `overflowing_add`, but that means it ends up being
        .                       // a `wrapping_add`, losing some optimization opportunities. Notably,
        .                       // phrasing it this way helps `.checked_add(1)` optimize to a check
        .                       // against `MAX` and a `add nuw`.
        .                       // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,
        .                       // LLVM is happy to re-form the intrinsic later if useful.
        .           
       25 ( 0.00%)              if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {
        .                           None
        .                       } else {
        .                           // SAFETY: Just checked it doesn't overflow
       15 ( 0.00%)                  Some(unsafe { intrinsics::unchecked_add(self, rhs) })
        .                       }
        .                   }
        .           
        .                   /// Strict integer addition. Computes `self + rhs`, panicking
        .                   /// if overflow occurred.
        .                   ///
        .                   /// # Panics
        .                   ///
-- line 506 ----------------------------------------
-- line 552 ----------------------------------------
        .                   #[doc = concat!("[`checked_add`]: ", stringify!($SelfT), "::checked_add")]
        .                   #[doc = concat!("[`wrapping_add`]: ", stringify!($SelfT), "::wrapping_add")]
        .                   #[stable(feature = "unchecked_math", since = "1.79.0")]
        .                   #[rustc_const_stable(feature = "unchecked_math", since = "1.79.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      321 ( 0.00%)          pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {
        .                       assert_unsafe_precondition!(
        .                           check_language_ub,
        .                           concat!(stringify!($SelfT), "::unchecked_add cannot overflow"),
        .                           (
        .                               lhs: $SelfT = self,
        .                               rhs: $SelfT = rhs,
   34,361 ( 0.03%)                  ) => !lhs.overflowing_add(rhs).1,
        .                       );
        .           
        .                       // SAFETY: this is guaranteed to be safe by the caller.
        .                       unsafe {
   34,361 ( 0.03%)                  intrinsics::unchecked_add(self, rhs)
        .                       }
        .                   }
        .           
        .                   /// Checked addition with a signed integer. Computes `self + rhs`,
        .                   /// returning `None` if overflow occurred.
        .                   ///
        .                   /// # Examples
        .                   ///
-- line 580 ----------------------------------------
-- line 862 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(5", stringify!($SelfT), ".checked_mul(1), Some(5));")]
        .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.checked_mul(2), None);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_checked_int_methods", since = "1.47.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline]
        1 ( 0.00%)          pub const fn checked_mul(self, rhs: Self) -> Option<Self> {
        .                       let (a, b) = self.overflowing_mul(rhs);
       24 ( 0.00%)              if intrinsics::unlikely(b) { None } else { Some(a) }
        .                   }
        .           
        .                   /// Strict integer multiplication. Computes `self * rhs`, panicking if
        .                   /// overflow occurred.
        .                   ///
        .                   /// # Panics
        .                   ///
        .                   /// ## Overflow behavior
-- line 880 ----------------------------------------
-- line 1973 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(200", stringify!($SelfT), ".wrapping_add(", stringify!($SelfT), "::MAX), 199);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn wrapping_add(self, rhs: Self) -> Self {
      102 ( 0.00%)              intrinsics::wrapping_add(self, rhs)
        .                   }
        .           
        .                   /// Wrapping (modular) addition with a signed integer. Computes
        .                   /// `self + rhs`, wrapping around at the boundary of the type.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 1989 ----------------------------------------
-- line 2013 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(100", stringify!($SelfT), ".wrapping_sub(100), 0);")]
        .                   #[doc = concat!("assert_eq!(100", stringify!($SelfT), ".wrapping_sub(", stringify!($SelfT), "::MAX), 101);")]
        .                   /// ```
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        3 ( 0.00%)          pub const fn wrapping_sub(self, rhs: Self) -> Self {
       12 ( 0.00%)              intrinsics::wrapping_sub(self, rhs)
        .                   }
        .           
        .                   /// Wrapping (modular) subtraction with a signed integer. Computes
        .                   /// `self - rhs`, wrapping around at the boundary of the type.
        .                   ///
        .                   /// # Examples
        .                   ///
        .                   /// Basic usage:
-- line 2030 ----------------------------------------
-- line 2343 ----------------------------------------
        .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.overflowing_add(1), (0, true));")]
        .                   /// ```
        .                   #[stable(feature = "wrapping", since = "1.7.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   #[inline(always)]
        .                   pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
   68,722 ( 0.06%)              let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
        .                       (a as Self, b)
        .                   }
        .           
        .                   /// Calculates `self` + `rhs` + `carry` and returns a tuple containing
        .                   /// the sum and the output carry.
        .                   ///
        .                   /// Performs "ternary addition" of two integer operands and a carry-in
        .                   /// bit, and returns an output integer and a carry-out bit. This allows
-- line 2359 ----------------------------------------
-- line 2541 ----------------------------------------
        .                                 without modifying the original"]
        .                   #[inline]
        .                   pub const fn abs_diff(self, other: Self) -> Self {
        .                       if mem::size_of::<Self>() == 1 {
        .                           // Trick LLVM into generating the psadbw instruction when SSE2
        .                           // is available and this function is autovectorized for u8's.
        .                           (self as i32).wrapping_sub(other as i32).abs() as Self
        .                       } else {
       30 ( 0.00%)                  if self < other {
       10 ( 0.00%)                      other - self
        .                           } else {
       10 ( 0.00%)                      self - other
        .                           }
        .                       }
        .                   }
        .           
        .                   /// Calculates the multiplication of `self` and `rhs`.
        .                   ///
        .                   /// Returns a tuple of the multiplication along with a boolean
        .                   /// indicating whether an arithmetic overflow would occur. If an
-- line 2560 ----------------------------------------
-- line 2571 ----------------------------------------
        .                   /// assert_eq!(5u32.overflowing_mul(2), (10, false));
        .                   /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));
        .                   /// ```
        .                   #[stable(feature = "wrapping", since = "1.7.0")]
        .                   #[rustc_const_stable(feature = "const_wrapping_math", since = "1.32.0")]
        .                   #[must_use = "this returns the result of the operation, \
        .                                     without modifying the original"]
        .                   #[inline(always)]
        1 ( 0.00%)          pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
       84 ( 0.00%)              let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);
       12 ( 0.00%)              (a as Self, b)
        .                   }
        .           
        .                   /// Calculates the complete product `self * rhs` without the possibility to overflow.
        .                   ///
        .                   /// This returns the low-order (wrapping) bits and the high-order (overflow) bits
        .                   /// of the result as two separate values, in that order.
        .                   ///
        .                   /// If you also need to add a carry to the wide result, then you want
-- line 2589 ----------------------------------------
-- line 3302 ----------------------------------------
        .                   /// ```
        .                   #[doc = concat!("assert!(16", stringify!($SelfT), ".is_power_of_two());")]
        .                   #[doc = concat!("assert!(!10", stringify!($SelfT), ".is_power_of_two());")]
        .                   /// ```
        .                   #[must_use]
        .                   #[stable(feature = "rust1", since = "1.0.0")]
        .                   #[rustc_const_stable(feature = "const_is_power_of_two", since = "1.32.0")]
        .                   #[inline(always)]
        6 ( 0.00%)          pub const fn is_power_of_two(self) -> bool {
        .                       self.count_ones() == 1
        .                   }
        .           
        .                   // Returns one less than next power of two.
        .                   // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)
        .                   //
        .                   // 8u8.one_less_than_next_power_of_two() == 7
        .                   // 6u8.one_less_than_next_power_of_two() == 7
-- line 3318 ----------------------------------------
-- line 3474 ----------------------------------------
        .                   #[must_use = "this returns the result of the operation, \
        .                                 without modifying the original"]
        .                   // SAFETY: const sound because integers are plain old datatypes so we can always
        .                   // transmute them to arrays of bytes
        .                   #[inline]
        .                   pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {
        .                       // SAFETY: integers are plain old datatypes so we can always transmute them to
        .                       // arrays of bytes
        5 ( 0.00%)              unsafe { mem::transmute(self) }
        .                   }
        .           
        .                   /// Creates a native endian integer value from its representation
        .                   /// as a byte array in big endian.
        .                   ///
        .                   #[doc = $from_xe_bytes_doc]
        .                   ///
        .                   /// # Examples
-- line 3490 ----------------------------------------

       20 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/niche_types.rs
--------------------------------------------------------------------------------
Ir               

-- line 46 ----------------------------------------
      .                       /// primitive without checking whether its zero.
      .                       ///
      .                       /// # Safety
      .                       /// Immediate language UB if `val == 0`, as it violates the validity
      .                       /// invariant of this type.
      .                       #[inline]
      .                       pub const unsafe fn new_unchecked(val: $int) -> Self {
      .                           // SAFETY: Caller promised that `val` is non-zero.
 64,005 ( 0.05%)                  unsafe { $name(val) }
      .                       }
      .           
      .                       #[inline]
      .                       pub const fn as_inner(self) -> $int {
      .                           // SAFETY: This is a transparent wrapper, so unwrapping it is sound
      .                           // (Not using `.0` due to MCP#807.)
 33,054 ( 0.03%)                  unsafe { crate::mem::transmute(self) }
      .                       }
      .                   }
      .           
      .                   // This is required to allow matching a constant.  We don't get it from a derive
      .                   // because the derived `PartialEq` would do a field projection, which is banned
      .                   // by <https://github.com/rust-lang/compiler-team/issues/807>.
      .                   impl StructuralPartialEq for $name {}
      .           
-- line 69 ----------------------------------------

129,067 ( 0.11%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/niche_types.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs
--------------------------------------------------------------------------------
Ir               

-- line 301 ----------------------------------------
      .           ///
      .           #[inline(always)]
      .           #[must_use]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[rustc_promotable]
      .           #[rustc_const_stable(feature = "const_mem_size_of", since = "1.24.0")]
      .           #[cfg_attr(not(test), rustc_diagnostic_item = "mem_size_of")]
      .           pub const fn size_of<T>() -> usize {
 97,357 ( 0.08%)      intrinsics::size_of::<T>()
      .           }
      .           
      .           /// Returns the size of the pointed-to value in bytes.
      .           ///
      .           /// This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no
      .           /// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],
      .           /// then `size_of_val` can be used to get the dynamically-known size.
      .           ///
-- line 317 ----------------------------------------
-- line 387 ----------------------------------------
      .           /// let y: &[u8] = &x;
      .           /// assert_eq!(13, unsafe { mem::size_of_val_raw(y) });
      .           /// ```
      .           #[inline]
      .           #[must_use]
      .           #[unstable(feature = "layout_for_ptr", issue = "69835")]
      .           pub const unsafe fn size_of_val_raw<T: ?Sized>(val: *const T) -> usize {
      .               // SAFETY: the caller must provide a valid raw pointer
     98 ( 0.00%)      unsafe { intrinsics::size_of_val(val) }
      .           }
      .           
      .           /// Returns the [ABI]-required minimum alignment of a type in bytes.
      .           ///
      .           /// Every reference to a value of the type `T` must be a multiple of this number.
      .           ///
      .           /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.
      .           ///
-- line 403 ----------------------------------------
-- line 459 ----------------------------------------
      .           /// assert_eq!(4, mem::align_of::<i32>());
      .           /// ```
      .           #[inline(always)]
      .           #[must_use]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[rustc_promotable]
      .           #[rustc_const_stable(feature = "const_align_of", since = "1.24.0")]
      .           pub const fn align_of<T>() -> usize {
      2 ( 0.00%)      intrinsics::min_align_of::<T>()
      .           }
      .           
      .           /// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to in
      .           /// bytes.
      .           ///
      .           /// Every reference to a value of the type `T` must be a multiple of this number.
      .           ///
      .           /// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface
-- line 475 ----------------------------------------
-- line 530 ----------------------------------------
      .           ///
      .           /// assert_eq!(4, unsafe { mem::align_of_val_raw(&5i32) });
      .           /// ```
      .           #[inline]
      .           #[must_use]
      .           #[unstable(feature = "layout_for_ptr", issue = "69835")]
      .           pub const unsafe fn align_of_val_raw<T: ?Sized>(val: *const T) -> usize {
      .               // SAFETY: the caller must provide a valid raw pointer
     98 ( 0.00%)      unsafe { intrinsics::min_align_of_val(val) }
      .           }
      .           
      .           /// Returns `true` if dropping values of type `T` matters.
      .           ///
      .           /// This is purely an optimization hint, and may be implemented conservatively:
      .           /// it may return `true` for types that don't actually need to be dropped.
      .           /// As such always returning `true` would be a valid implementation of
      .           /// this function. However if this function actually returns `false`, then you
-- line 546 ----------------------------------------
-- line 725 ----------------------------------------
      .           /// ```
      .           #[inline]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[rustc_const_stable(feature = "const_swap", since = "1.85.0")]
      .           #[rustc_diagnostic_item = "mem_swap"]
      .           pub const fn swap<T>(x: &mut T, y: &mut T) {
      .               // SAFETY: `&mut` guarantees these are typed readable and writable
      .               // as well as non-overlapping.
     13 ( 0.00%)      unsafe { intrinsics::typed_swap_nonoverlapping(x, y) }
      .           }
      .           
      .           /// Replaces `dest` with the default value of `T`, returning the previous `dest` value.
      .           ///
      .           /// * If you want to replace the values of two variables, see [`swap`].
      .           /// * If you want to replace with a passed value instead of the default value, see [`replace`].
      .           ///
      .           /// # Examples
-- line 741 ----------------------------------------
-- line 785 ----------------------------------------
      .           /// let mut buffer = Buffer { buf: vec![0, 1] };
      .           /// assert_eq!(buffer.buf.len(), 2);
      .           ///
      .           /// assert_eq!(buffer.get_and_reset(), vec![0, 1]);
      .           /// assert_eq!(buffer.buf.len(), 0);
      .           /// ```
      .           #[inline]
      .           #[stable(feature = "mem_take", since = "1.40.0")]
     10 ( 0.00%)  pub fn take<T: Default>(dest: &mut T) -> T {
     10 ( 0.00%)      replace(dest, T::default())
     14 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T> as core::default::Default>::default (2x)
      4 ( 0.00%)  }
      .           
      .           /// Moves `src` into the referenced `dest`, returning the previous `dest` value.
      .           ///
      .           /// Neither value is dropped.
      .           ///
      .           /// * If you want to replace the values of two variables, see [`swap`].
      .           /// * If you want to replace with a default value, see [`take`].
      .           ///
-- line 803 ----------------------------------------
-- line 932 ----------------------------------------
      .           ///
      .           /// println!("x: {}, y: {}", x, y.0); // still available
      .           /// ```
      .           ///
      .           /// [`RefCell`]: crate::cell::RefCell
      .           #[inline]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[cfg_attr(not(test), rustc_diagnostic_item = "mem_drop")]
288,024 ( 0.24%)  pub fn drop<T>(_x: T) {}
2,496,000 ( 2.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::sync::poison::mutex::MutexGuard<multi_producer::EventCounters>> (32,000x)
      .           
      .           /// Bitwise-copies a value.
      .           ///
      .           /// This function is not magic; it is literally defined as
      .           /// ```
      .           /// pub fn copy<T: Copy>(x: &T) -> T { *x }
      .           /// ```
      .           ///
-- line 948 ----------------------------------------

  1,066 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs
--------------------------------------------------------------------------------
Ir               

-- line 91 ----------------------------------------
      .               ///
      .               /// This is a [Strict Provenance][crate::ptr#strict-provenance] API.
      .               #[unstable(feature = "nonnull_provenance", issue = "135243")]
      .               #[must_use]
      .               #[inline]
      .               pub const fn without_provenance(addr: NonZero<usize>) -> Self {
      .                   let pointer = crate::ptr::without_provenance(addr.get());
      .                   // SAFETY: we know `addr` is non-zero.
      2 ( 0.00%)          unsafe { NonNull { pointer } }
      .               }
      .           
      .               /// Creates a new `NonNull` that is dangling, but well-aligned.
      .               ///
      .               /// This is useful for initializing types which lazily allocate, like
      .               /// `Vec::new` does.
      .               ///
      .               /// Note that the pointer value may potentially represent a valid pointer to
-- line 107 ----------------------------------------
-- line 218 ----------------------------------------
      .               #[rustc_const_stable(feature = "const_nonnull_new_unchecked", since = "1.25.0")]
      .               #[inline]
      .               pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {
      .                   // SAFETY: the caller must guarantee that `ptr` is non-null.
      .                   unsafe {
      .                       assert_unsafe_precondition!(
      .                           check_language_ub,
      .                           "NonNull::new_unchecked requires that the pointer is non-null",
192,144 ( 0.16%)                  (ptr: *mut () = ptr as *mut ()) => !ptr.is_null()
      .                       );
      8 ( 0.00%)              NonNull { pointer: ptr as _ }
      .                   }
      .               }
      .           
      .               /// Creates a new `NonNull` if `ptr` is non-null.
      .               ///
      .               /// # Panics during const evaluation
      .               ///
      .               /// This method will panic during const evaluation if the pointer cannot be
-- line 236 ----------------------------------------
-- line 249 ----------------------------------------
      .               /// if let Some(ptr) = NonNull::<u32>::new(std::ptr::null_mut()) {
      .               ///     unreachable!();
      .               /// }
      .               /// ```
      .               #[stable(feature = "nonnull", since = "1.25.0")]
      .               #[rustc_const_stable(feature = "const_nonnull_new", since = "1.85.0")]
      .               #[inline]
      .               pub const fn new(ptr: *mut T) -> Option<Self> {
 64,058 ( 0.05%)          if !ptr.is_null() {
      .                       // SAFETY: The pointer is already checked and is not null
 32,029 ( 0.03%)              Some(unsafe { Self::new_unchecked(ptr) })
      .                   } else {
      .                       None
      .                   }
      .               }
      .           
      .               /// Converts a reference to a `NonNull` pointer.
      .               #[unstable(feature = "non_null_from_ref", issue = "130823")]
      .               #[inline]
      .               pub const fn from_ref(r: &T) -> Self {
      .                   // SAFETY: A reference cannot be null.
    662 ( 0.00%)          unsafe { NonNull { pointer: r as *const T } }
      .               }
      .           
      .               /// Converts a mutable reference to a `NonNull` pointer.
      .               #[unstable(feature = "non_null_from_ref", issue = "130823")]
      .               #[inline]
      .               pub const fn from_mut(r: &mut T) -> Self {
      .                   // SAFETY: A mutable reference cannot be null.
     16 ( 0.00%)          unsafe { NonNull { pointer: r as *mut T } }
      .               }
      .           
      .               /// Performs the same functionality as [`std::ptr::from_raw_parts`], except that a
      .               /// `NonNull` pointer is returned, as opposed to a raw `*const` pointer.
      .               ///
      .               /// See the documentation of [`std::ptr::from_raw_parts`] for more details.
      .               ///
      .               /// [`std::ptr::from_raw_parts`]: crate::ptr::from_raw_parts
-- line 286 ----------------------------------------
-- line 384 ----------------------------------------
      .               #[must_use]
      .               #[inline(always)]
      .               pub const fn as_ptr(self) -> *mut T {
      .                   // This is a transmute for the same reasons as `NonZero::get`.
      .           
      .                   // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`
      .                   // and `*mut T` have the same layout, so transitively we can transmute
      .                   // our `NonNull` to a `*mut T` directly.
193,812 ( 0.16%)          unsafe { mem::transmute::<Self, *mut T>(self) }
      .               }
      .           
      .               /// Returns a shared reference to the value. If the value may be uninitialized, [`as_uninit_ref`]
      .               /// must be used instead.
      .               ///
      .               /// For the mutable counterpart see [`as_mut`].
      .               ///
      .               /// [`as_uninit_ref`]: NonNull::as_uninit_ref
-- line 400 ----------------------------------------
-- line 421 ----------------------------------------
      .               #[stable(feature = "nonnull", since = "1.25.0")]
      .               #[rustc_const_stable(feature = "const_nonnull_as_ref", since = "1.73.0")]
      .               #[must_use]
      .               #[inline(always)]
      .               pub const unsafe fn as_ref<'a>(&self) -> &'a T {
      .                   // SAFETY: the caller must guarantee that `self` meets all the
      .                   // requirements for a reference.
      .                   // `cast_const` avoids a mutable raw pointer deref.
513,141 ( 0.43%)          unsafe { &*self.as_ptr().cast_const() }
      .               }
      .           
      .               /// Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]
      .               /// must be used instead.
      .               ///
      .               /// For the shared counterpart see [`as_ref`].
      .               ///
      .               /// [`as_uninit_mut`]: NonNull::as_uninit_mut
-- line 437 ----------------------------------------
-- line 481 ----------------------------------------
      .               /// ```
      .               #[stable(feature = "nonnull_cast", since = "1.27.0")]
      .               #[rustc_const_stable(feature = "const_nonnull_cast", since = "1.36.0")]
      .               #[must_use = "this returns the result of the operation, \
      .                             without modifying the original"]
      .               #[inline]
      .               pub const fn cast<U>(self) -> NonNull<U> {
      .                   // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null
 96,359 ( 0.08%)          unsafe { NonNull { pointer: self.as_ptr() as *mut U } }
      .               }
      .           
      .               /// Adds an offset to a pointer.
      .               ///
      .               /// `count` is in units of T; e.g., a `count` of 3 represents a pointer
      .               /// offset of `3 * size_of::<T>()` bytes.
      .               ///
      .               /// # Safety
-- line 497 ----------------------------------------
-- line 601 ----------------------------------------
      .               ///     println!("{}", ptr.add(2).read() as char);
      .               /// }
      .               /// ```
      .               #[inline(always)]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .               #[must_use = "returns a new pointer rather than modifying its argument"]
      .               #[stable(feature = "non_null_convenience", since = "1.80.0")]
      .               #[rustc_const_stable(feature = "non_null_convenience", since = "1.80.0")]
 64,349 ( 0.05%)      pub const unsafe fn add(self, count: usize) -> Self
      .               where
      .                   T: Sized,
      .               {
      .                   // SAFETY: the caller must uphold the safety contract for `offset`.
      .                   // Additionally safety contract of `offset` guarantees that the resulting pointer is
      .                   // pointing to an allocation, there can't be an allocation at null, thus it's safe to
      .                   // construct `NonNull`.
 65,247 ( 0.06%)          unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }
      .               }
      .           
      .               /// Calculates the offset from a pointer in bytes (convenience for `.byte_offset(count as isize)`).
      .               ///
      .               /// `count` is in units of bytes.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
      .               /// using [`add`][NonNull::add] on it. See that method for documentation
-- line 625 ----------------------------------------
-- line 900 ----------------------------------------
      .               ///
      .               /// // This would be incorrect, as the pointers are not correctly ordered:
      .               /// // ptr1.sub_ptr(ptr2)
      .               /// ```
      .               #[inline]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .               #[unstable(feature = "ptr_sub_ptr", issue = "95892")]
      .               #[rustc_const_unstable(feature = "const_ptr_sub_ptr", issue = "95892")]
321,525 ( 0.27%)      pub const unsafe fn sub_ptr(self, subtracted: NonNull<T>) -> usize
      .               where
      .                   T: Sized,
      .               {
      .                   // SAFETY: the caller must uphold the safety contract for `sub_ptr`.
 64,305 ( 0.05%)          unsafe { self.as_ptr().sub_ptr(subtracted.as_ptr()) }
128,610 ( 0.11%)      }
      .           
      .               /// Calculates the distance between two pointers within the same allocation, *where it's known that
      .               /// `self` is equal to or greater than `origin`*. The returned value is in
      .               /// units of **bytes**.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
      .               /// using [`sub_ptr`][NonNull::sub_ptr] on it. See that method for
      .               /// documentation and safety requirements.
-- line 922 ----------------------------------------
-- line 1345 ----------------------------------------
      .               /// ```
      .               ///
      .               /// (Note that this example artificially demonstrates a use of this method,
      .               /// but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)
      .               #[stable(feature = "nonnull_slice_from_raw_parts", since = "1.70.0")]
      .               #[rustc_const_stable(feature = "const_slice_from_raw_parts_mut", since = "1.83.0")]
      .               #[must_use]
      .               #[inline]
 32,031 ( 0.03%)      pub const fn slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self {
      .                   // SAFETY: `data` is a `NonNull` pointer which is necessarily non-null
      .                   unsafe { Self::new_unchecked(super::slice_from_raw_parts_mut(data.as_ptr(), len)) }
      .               }
      .           
      .               /// Returns the length of a non-null raw slice.
      .               ///
      .               /// The returned value is the number of **elements**, not the number of bytes.
      .               ///
-- line 1361 ----------------------------------------
-- line 1615 ----------------------------------------
      .           #[stable(feature = "nonnull", since = "1.25.0")]
      .           impl<T: ?Sized> Eq for NonNull<T> {}
      .           
      .           #[stable(feature = "nonnull", since = "1.25.0")]
      .           impl<T: ?Sized> PartialEq for NonNull<T> {
      .               #[inline]
      .               #[allow(ambiguous_wide_pointer_comparisons)]
      .               fn eq(&self, other: &Self) -> bool {
131,314 ( 0.11%)          self.as_ptr() == other.as_ptr()
      .               }
      .           }
      .           
      .           #[stable(feature = "nonnull", since = "1.25.0")]
      .           impl<T: ?Sized> Ord for NonNull<T> {
      .               #[inline]
      .               #[allow(ambiguous_wide_pointer_comparisons)]
      .               fn cmp(&self, other: &Self) -> Ordering {
-- line 1631 ----------------------------------------

129,051 ( 0.11%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs
--------------------------------------------------------------------------------
Ir               

-- line 36 ----------------------------------------
      .           /// assert_eq!(a, b, "we are testing addition with {} and {}", a, b);
      .           /// ```
      .           #[macro_export]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[cfg_attr(not(test), rustc_diagnostic_item = "assert_eq_macro")]
      .           #[allow_internal_unstable(panic_internals)]
      .           macro_rules! assert_eq {
      .               ($left:expr, $right:expr $(,)?) => {
256,016 ( 0.22%)          match (&$left, &$right) {
      .                       (left_val, right_val) => {
128,008 ( 0.11%)                  if !(*left_val == *right_val) {
 64,004 ( 0.05%)                      let kind = $crate::panicking::AssertKind::Eq;
      .                               // The reborrows below are intentional. Without them, the stack slot for the
      .                               // borrow is initialized even before the values are compared, leading to a
      .                               // noticeable slow down.
      .                               $crate::panicking::assert_failed(kind, &*left_val, &*right_val, $crate::option::Option::None);
      .                           }
      .                       }
      .                   }
      .               };
-- line 55 ----------------------------------------
-- line 530 ----------------------------------------
      .           /// let bar = Some(4);
      .           /// assert!(matches!(bar, Some(x) if x > 2));
      .           /// ```
      .           #[macro_export]
      .           #[stable(feature = "matches_macro", since = "1.42.0")]
      .           #[cfg_attr(not(test), rustc_diagnostic_item = "matches_macro")]
      .           macro_rules! matches {
      .               ($expression:expr, $pattern:pat $(if $guard:expr)? $(,)?) => {
192,020 ( 0.16%)          match $expression {
      .                       $pattern $(if $guard)? => true,
      .                       _ => false
      .                   }
      .               };
      .           }
      .           
      .           /// Unwraps a result or propagates its error.
      .           ///
-- line 546 ----------------------------------------

 64,004 ( 0.05%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/producer/producer.rs
--------------------------------------------------------------------------------
Ir               

-- line 4 ----------------------------------------
      .           
      .           pub struct Producer<T, S: Sequencer, D: DataStorage<T>> {
      .               sequencer: Arc<S>,
      .               data_storage: Arc<D>,
      .               phantom_data: PhantomData<T>,
      .           }
      .           
      .           impl<T: Default, S: Sequencer, D: DataStorage<T>> Producer<T, S, D> {
     12 ( 0.00%)      pub fn new(sequencer: Arc<S>, data_storage: Arc<D>) -> Self {
      8 ( 0.00%)          Self {
      4 ( 0.00%)              sequencer,
      4 ( 0.00%)              data_storage,
      8 ( 0.00%)              phantom_data: PhantomData::default()
      4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/marker.rs:<core::marker::PhantomData<T> as core::default::Default>::default (4x)
      .                   }
      8 ( 0.00%)      }
      .           }
      .           
      .           impl<T, S: Sequencer, D: DataStorage<T>> EventProducer for Producer<T, S, D> {
      .               type Event = T;
 96,000 ( 0.08%)      fn write<E, F, G>(&self, events: E, func: F)
      .               where
      .                   E: IntoIterator<Item = T, IntoIter = G>,
      .                   F: Fn(&mut T, Sequence, &T),
      .                   G: ExactSizeIterator<Item = T>
      .               {
      .                   // 1. get items iterator
192,000 ( 0.16%)          let items = events.into_iter();
1,792,000 ( 1.52%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::iter::traits::collect::IntoIterator>::into_iter (32,000x)
128,000 ( 0.11%)          let items_len = items.len();
2,944,000 ( 2.49%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:core::iter::traits::exact_size::ExactSizeIterator::len (32,000x)
      .                   
      .                   // 2. get start and end slots for available for these events from sequencer
416,000 ( 0.35%)          let (start, end) = self.sequencer.next(items_len);
6,080,000 ( 5.15%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/sequencer.rs:<oxidator::coordinator::sequencer::MultiProducerSequencer<W> as oxidator::traits::traits::Sequencer>::next (32,000x)
128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
      .                   
      .                   // 3. loop through items
960,000 ( 0.81%)          for (i, item) in items.enumerate() {
4,288,000 ( 3.63%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/enumerate.rs:<core::iter::adapters::enumerate::Enumerate<I> as core::iter::traits::iterator::Iterator>::next (64,000x)
672,000 ( 0.57%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (32,000x)
384,000 ( 0.32%)  => ???:__memcpy_avx_unaligned_erms (32,000x)
352,000 ( 0.30%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:core::iter::traits::iterator::Iterator::enumerate (32,000x)
      .                       // 4. get data provider slot and write to it
192,000 ( 0.16%)              let sequence = start + i as Sequence;
      .                       unsafe {
320,000 ( 0.27%)                  let slot = &mut self.data_storage.get_data_mut(sequence);
5,152,000 ( 4.36%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/storage/ring_buffer.rs:<oxidator::storage::ring_buffer::RingBuffer<T> as oxidator::traits::traits::DataStorage<T>>::get_data_mut (32,000x)
128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
352,000 ( 0.30%)                  func(slot, sequence, &item);
608,000 ( 0.51%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/samples/multi_producer_sample.rs:multi_producer::main::{{closure}}::{{closure}} (32,000x)
      .                       };
 96,000 ( 0.08%)          }
9,056,000 ( 7.66%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<core::iter::adapters::enumerate::Enumerate<alloc::vec::into_iter::IntoIter<multi_producer::Event>>> (32,000x)
      .                   // 5. exit loop
      .                   // 6. publish on sequencer
160,000 ( 0.14%)          self.sequencer.publish(start, end);
33,888,000 (28.68%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/sequencer.rs:<oxidator::coordinator::sequencer::MultiProducerSequencer<W> as oxidator::traits::traits::Sequencer>::publish (32,000x)
128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
 96,000 ( 0.08%)      }
      .           
      2 ( 0.00%)      fn drain(&self) {
      3 ( 0.00%)          self.sequencer.drain();
     66 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/sequencer.rs:<oxidator::coordinator::sequencer::MultiProducerSequencer<W> as oxidator::traits::traits::Sequencer>::drain (1x)
      4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
      2 ( 0.00%)      }
      .           }
      .           
      .           impl<T, S: Sequencer, D: DataStorage<T>> Clone for Producer<T, S, D> {
     12 ( 0.00%)      fn clone(&self) -> Self {
      4 ( 0.00%)          Self {
     12 ( 0.00%)              sequencer: Arc::clone(&self.sequencer),
    120 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (4x)
     16 ( 0.00%)              data_storage: Arc::clone(&self.data_storage),
    120 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (4x)
      .                       phantom_data: PhantomData,
      .                   }
      8 ( 0.00%)      }
      .           }
      .           
      .           #[cfg(test)]
      .           mod consumer_test {
      .               use super::*;
      .               use std::sync::Arc;
      .               use crate::coordinator::*;
      .               use crate::producer::Producer;
-- line 70 ----------------------------------------

768,004 ( 0.65%)  <counts for unidentified lines in src/producer/producer.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/coordinator/wait.rs
--------------------------------------------------------------------------------
Ir              

-- line 89 ----------------------------------------
     .               }
     .           
     .               fn signal(&self) {}
     .           }
     .           
     .           impl WaitStrategy for YieldingWaitStrategy {
     .               fn new() -> Self {
     .                   Self{}
     2 ( 0.00%)      }
     .           
   150 ( 0.00%)      fn wait_for<T: AsRef<AtomicSequence>, F: Fn() -> bool>(
     .                   &self,
     .                   sequence: Sequence,
     .                   dependencies: &[T],
     .                   check_alert: F
     .               ) -> Option<Sequence> {
    60 ( 0.00%)          if dependencies.is_empty() {
    60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:core::slice::<impl [T]>::is_empty (10x)
     .                       return None;
     .                   }
     .           
     .                   loop {
 1,276 ( 0.00%)              let slowest_dependency = min_sequence(dependencies);
147,383 ( 0.12%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/utils/helpers.rs:oxidator::utils::helpers::min_sequence (319x)
   638 ( 0.00%)              if slowest_dependency >= sequence {
    16 ( 0.00%)                  return Some(slowest_dependency);
     .                       }
     .           
 1,864 ( 0.00%)              if check_alert() {
16,794 ( 0.01%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/barrier.rs:<oxidator::coordinator::barrier::DefaultSequenceBarrier<W> as oxidator::traits::traits::SequenceBarrier>::wait_for::{{closure}} (311x)
     8 ( 0.00%)                  let final_check = min_sequence(dependencies);
   732 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/utils/helpers.rs:oxidator::utils::helpers::min_sequence (2x)
     4 ( 0.00%)                  if final_check >= sequence {
     .                               return Some(final_check);
     .                           }
     4 ( 0.00%)                  return None
     .                       }
     .           
 1,236 ( 0.00%)              thread::yield_now();
 3,090 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/thread/mod.rs:std::thread::yield_now (309x)
     .                   }
    40 ( 0.00%)      }
     .           
64,018 ( 0.05%)      fn signal(&self) {}
     .           }
     .           
     .           #[cfg(test)]
     .           mod test_wait {
     .               use super::*;
     .               use std::sync::Arc;
     .               use std::time::{Duration, Instant};
     .               
-- line 135 ----------------------------------------

   975 ( 0.00%)  <counts for unidentified lines in src/coordinator/wait.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs
--------------------------------------------------------------------------------
Ir               

-- line 178 ----------------------------------------
      .           
      .               /// Like `with_capacity`, but parameterized over the choice of
      .               /// allocator for the returned `RawVec`.
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[track_caller]
      .               pub(crate) fn with_capacity_in(capacity: usize, alloc: A) -> Self {
      .                   Self {
     15 ( 0.00%)              inner: RawVecInner::with_capacity_in(capacity, alloc, T::LAYOUT),
    291 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVecInner<A>::with_capacity_in (1x)
      .                       _marker: PhantomData,
      .                   }
      .               }
      .           
      .               /// Like `try_with_capacity`, but parameterized over the choice of
      .               /// allocator for the returned `RawVec`.
      .               #[inline]
      .               pub(crate) fn try_with_capacity_in(capacity: usize, alloc: A) -> Result<Self, TryReserveError> {
-- line 194 ----------------------------------------
-- line 248 ----------------------------------------
      .               /// guaranteed.
      .               #[inline]
      .               pub(crate) unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, alloc: A) -> Self {
      .                   // SAFETY: Precondition passed to the caller
      .                   unsafe {
      .                       let ptr = ptr.cast();
      .                       let capacity = new_cap::<T>(capacity);
      .                       Self {
 96,003 ( 0.08%)                  inner: RawVecInner::from_raw_parts_in(ptr, capacity, alloc),
      .                           _marker: PhantomData,
      .                       }
      .                   }
      .               }
      .           
      .               /// A convenience method for hoisting the non-null precondition out of [`RawVec::from_raw_parts_in`].
      .               ///
      .               /// # Safety
-- line 264 ----------------------------------------
-- line 265 ----------------------------------------
      .               ///
      .               /// See [`RawVec::from_raw_parts_in`].
      .               #[inline]
      .               pub(crate) unsafe fn from_nonnull_in(ptr: NonNull<T>, capacity: usize, alloc: A) -> Self {
      .                   // SAFETY: Precondition passed to the caller
      .                   unsafe {
      .                       let ptr = ptr.cast();
      .                       let capacity = new_cap::<T>(capacity);
128,016 ( 0.11%)              Self { inner: RawVecInner::from_nonnull_in(ptr, capacity, alloc), _marker: PhantomData }
      .                   }
      .               }
      .           
      .               /// Gets a raw pointer to the start of the allocation. Note that this is
      .               /// `Unique::dangling()` if `capacity == 0` or `T` is zero-sized. In the former case, you must
      .               /// be careful.
      .               #[inline]
      .               pub(crate) const fn ptr(&self) -> *mut T {
-- line 281 ----------------------------------------
-- line 287 ----------------------------------------
      .                   self.inner.non_null()
      .               }
      .           
      .               /// Gets the capacity of the allocation.
      .               ///
      .               /// This will always be `usize::MAX` if `T` is zero-sized.
      .               #[inline]
      .               pub(crate) const fn capacity(&self) -> usize {
 65,054 ( 0.06%)          self.inner.capacity(size_of::<T>())
      .               }
      .           
      .               /// Returns a shared reference to the allocator backing this `RawVec`.
      .               #[inline]
      .               pub(crate) fn allocator(&self) -> &A {
      .                   self.inner.allocator()
      .               }
      .           
-- line 303 ----------------------------------------
-- line 319 ----------------------------------------
      .               ///
      .               /// # Aborts
      .               ///
      .               /// Aborts on OOM.
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[track_caller]
      .               pub(crate) fn reserve(&mut self, len: usize, additional: usize) {
      3 ( 0.00%)          self.inner.reserve(len, additional, T::LAYOUT)
      .               }
      .           
      .               /// A specialized version of `self.reserve(len, 1)` which requires the
      .               /// caller to ensure `len == self.capacity()`.
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline(never)]
      .               #[track_caller]
     27 ( 0.00%)      pub(crate) fn grow_one(&mut self) {
      9 ( 0.00%)          self.inner.grow_one(T::LAYOUT)
     18 ( 0.00%)      }
      .           
      .               /// The same as `reserve`, but returns on errors instead of panicking or aborting.
      .               pub(crate) fn try_reserve(
      .                   &mut self,
      .                   len: usize,
      .                   additional: usize,
      .               ) -> Result<(), TryReserveError> {
      .                   self.inner.try_reserve(len, additional, T::LAYOUT)
-- line 345 ----------------------------------------
-- line 392 ----------------------------------------
      .               #[inline]
      .               pub(crate) fn shrink_to_fit(&mut self, cap: usize) {
      .                   self.inner.shrink_to_fit(cap, T::LAYOUT)
      .               }
      .           }
      .           
      .           unsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {
      .               /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.
 64,046 ( 0.05%)      fn drop(&mut self) {
      .                   // SAFETY: We are in a Drop impl, self.inner will not be used again.
 96,069 ( 0.08%)          unsafe { self.inner.deallocate(T::LAYOUT) }
3,842,079 ( 3.25%)  => ???:alloc::raw_vec::RawVecInner<A>::deallocate (32,023x)
 64,046 ( 0.05%)      }
      .           }
      .           
      .           impl<A: Allocator> RawVecInner<A> {
      .               #[inline]
      .               const fn new_in(alloc: A, align: usize) -> Self {
      .                   let ptr = unsafe { core::mem::transmute(align) };
      .                   // `cap: 0` means "unallocated". zero-sized types are ignored.
      .                   Self { ptr, cap: ZERO_CAP, alloc }
      .               }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[track_caller]
     36 ( 0.00%)      fn with_capacity_in(capacity: usize, alloc: A, elem_layout: Layout) -> Self {
     15 ( 0.00%)          match Self::try_allocate_in(capacity, AllocInit::Uninitialized, alloc, elem_layout) {
    496 ( 0.00%)  => ???:alloc::raw_vec::RawVecInner<A>::try_allocate_in (3x)
     12 ( 0.00%)              Ok(this) => {
      .                           unsafe {
      .                               // Make it more obvious that a subsequent Vec::reserve(capacity) will not allocate.
     24 ( 0.00%)                      hint::assert_unchecked(!this.needs_to_grow(0, capacity, elem_layout));
      .                           }
      6 ( 0.00%)                  this
      .                       }
      .                       Err(err) => handle_error(err),
      .                   }
      6 ( 0.00%)      }
      .           
      .               #[inline]
      .               fn try_with_capacity_in(
      .                   capacity: usize,
      .                   alloc: A,
      .                   elem_layout: Layout,
      .               ) -> Result<Self, TryReserveError> {
      .                   Self::try_allocate_in(capacity, AllocInit::Uninitialized, alloc, elem_layout)
      .               }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[track_caller]
      8 ( 0.00%)      fn with_capacity_zeroed_in(capacity: usize, alloc: A, elem_layout: Layout) -> Self {
     36 ( 0.00%)          match Self::try_allocate_in(capacity, AllocInit::Zeroed, alloc, elem_layout) {
  1,136 ( 0.00%)  => ???:alloc::raw_vec::RawVecInner<A>::try_allocate_in (4x)
     16 ( 0.00%)              Ok(res) => res,
      .                       Err(err) => handle_error(err),
      .                   }
      .               }
      .           
      .               fn try_allocate_in(
      .                   capacity: usize,
      .                   init: AllocInit,
      .                   alloc: A,
-- line 452 ----------------------------------------
-- line 500 ----------------------------------------
      .           
      .               #[inline]
      .               const fn ptr<T>(&self) -> *mut T {
      .                   self.non_null::<T>().as_ptr()
      .               }
      .           
      .               #[inline]
      .               const fn non_null<T>(&self) -> NonNull<T> {
449,132 ( 0.38%)          self.ptr.cast().as_non_null_ptr()
      .               }
      .           
      .               #[inline]
      .               const fn capacity(&self, elem_size: usize) -> usize {
 66,117 ( 0.06%)          if elem_size == 0 { usize::MAX } else { self.cap.as_inner() }
      .               }
      .           
      .               #[inline]
      .               fn allocator(&self) -> &A {
      1 ( 0.00%)          &self.alloc
      .               }
      .           
      .               #[inline]
      .               fn current_memory(&self, elem_layout: Layout) -> Option<(NonNull<u8>, Layout)> {
      .                   if elem_layout.size() == 0 || self.cap.as_inner() == 0 {
      .                       None
      .                   } else {
      .                       // We could use Layout::array here which ensures the absence of isize and usize overflows
-- line 526 ----------------------------------------
-- line 550 ----------------------------------------
      .                       additional: usize,
      .                       elem_layout: Layout,
      .                   ) {
      .                       if let Err(err) = slf.grow_amortized(len, additional, elem_layout) {
      .                           handle_error(err);
      .                       }
      .                   }
      .           
      4 ( 0.00%)          if self.needs_to_grow(len, additional, elem_layout) {
      .                       do_reserve_and_handle(self, len, additional, elem_layout);
      .                   }
      .               }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[track_caller]
     18 ( 0.00%)      fn grow_one(&mut self, elem_layout: Layout) {
    135 ( 0.00%)          if let Err(err) = self.grow_amortized(self.cap.as_inner(), 1, elem_layout) {
  2,607 ( 0.00%)  => ???:alloc::raw_vec::RawVecInner<A>::grow_amortized (9x)
      .                       handle_error(err);
      .                   }
      .               }
      .           
      .               fn try_reserve(
      .                   &mut self,
      .                   len: usize,
      .                   additional: usize,
-- line 575 ----------------------------------------
-- line 614 ----------------------------------------
      .               #[track_caller]
      .               fn shrink_to_fit(&mut self, cap: usize, elem_layout: Layout) {
      .                   if let Err(err) = self.shrink(cap, elem_layout) {
      .                       handle_error(err);
      .                   }
      .               }
      .           
      .               #[inline]
      3 ( 0.00%)      fn needs_to_grow(&self, len: usize, additional: usize, elem_layout: Layout) -> bool {
     15 ( 0.00%)          additional > self.capacity(elem_layout.size()).wrapping_sub(len)
      .               }
      .           
      .               #[inline]
      .               unsafe fn set_ptr_and_cap(&mut self, ptr: NonNull<[u8]>, cap: usize) {
      .                   // Allocators currently return a `NonNull<[u8]>` whose length matches
      .                   // the size requested. If that ever changes, the capacity here should
      .                   // change to `ptr.len() / mem::size_of::<T>()`.
      .                   self.ptr = Unique::from(ptr.cast());
-- line 631 ----------------------------------------

 32,022 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs
--------------------------------------------------------------------------------
Ir               

-- line 8 ----------------------------------------
      .           impl<T, I> ops::Index<I> for [T]
      .           where
      .               I: SliceIndex<[T]>,
      .           {
      .               type Output = I::Output;
      .           
      .               #[inline(always)]
      .               fn index(&self, index: I) -> &I::Output {
 96,006 ( 0.08%)          index.index(self)
1,536,095 ( 1.30%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::index (96,006x)
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T, I> ops::IndexMut<I> for [T]
      .           where
      .               I: SliceIndex<[T]>,
      .           {
      .               #[inline(always)]
      .               fn index_mut(&mut self, index: I) -> &mut I::Output {
      3 ( 0.00%)          index.index_mut(self)
     45 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::index_mut (3x)
      .               }
      .           }
      .           
      .           #[cfg_attr(not(feature = "panic_immediate_abort"), inline(never), cold)]
      .           #[cfg_attr(feature = "panic_immediate_abort", inline)]
      .           #[track_caller]
      .           const fn slice_start_index_len_fail(index: usize, len: usize) -> ! {
      .               const_panic!(
-- line 35 ----------------------------------------
-- line 82 ----------------------------------------
      .           // them in safe indexing is unnecessary and hurts inlining and debug runtime perf.
      .           // Both the safe and unsafe public methods share these helpers,
      .           // which use intrinsics directly to get *no* extra checks.
      .           
      .           #[inline(always)]
      .           const unsafe fn get_noubcheck<T>(ptr: *const [T], index: usize) -> *const T {
      .               let ptr = ptr as *const T;
      .               // SAFETY: The caller already checked these preconditions
192,000 ( 0.16%)      unsafe { crate::intrinsics::offset(ptr, index) }
      .           }
      .           
      .           #[inline(always)]
      .           const unsafe fn get_mut_noubcheck<T>(ptr: *mut [T], index: usize) -> *mut T {
      .               let ptr = ptr as *mut T;
      .               // SAFETY: The caller already checked these preconditions
      .               unsafe { crate::intrinsics::offset(ptr, index) }
      .           }
-- line 98 ----------------------------------------
-- line 234 ----------------------------------------
      .                       // SAFETY: `self` is checked to be in bounds.
      .                       unsafe { Some(&mut *get_mut_noubcheck(slice, self)) }
      .                   } else {
      .                       None
      .                   }
      .               }
      .           
      .               #[inline]
864,000 ( 0.73%)      unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {
      .                   assert_unsafe_precondition!(
      .                       check_language_ub,
      .                       "slice::get_unchecked requires that the index is within the slice",
192,000 ( 0.16%)              (this: usize = self, len: usize = slice.len()) => this < len
      .                   );
      .                   // SAFETY: the caller guarantees that `slice` is not dangling, so it
      .                   // cannot be longer than `isize::MAX`. They also guarantee that
      .                   // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,
      .                   // so the call to `add` is safe.
      .                   unsafe {
      .                       // Use intrinsics::assume instead of hint::assert_unchecked so that we don't check the
      .                       // precondition of this function twice.
      .                       crate::intrinsics::assume(self < slice.len());
      .                       get_noubcheck(slice, self)
      .                   }
192,000 ( 0.16%)      }
      .           
      .               #[inline]
      .               unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {
      .                   assert_unsafe_precondition!(
      .                       check_library_ub,
      .                       "slice::get_unchecked_mut requires that the index is within the slice",
      .                       (this: usize = self, len: usize = slice.len()) => this < len
      .                   );
      .                   // SAFETY: see comments for `get_unchecked` above.
      .                   unsafe { get_mut_noubcheck(slice, self) }
      .               }
      .           
      .               #[inline]
768,048 ( 0.65%)      fn index(self, slice: &[T]) -> &T {
      .                   // N.B., use intrinsic indexing
384,023 ( 0.32%)          &(*slice)[self]
192,012 ( 0.16%)      }
      .           
      .               #[inline]
     24 ( 0.00%)      fn index_mut(self, slice: &mut [T]) -> &mut T {
      .                   // N.B., use intrinsic indexing
      9 ( 0.00%)          &mut (*slice)[self]
      6 ( 0.00%)      }
      .           }
      .           
      .           /// Because `IndexRange` guarantees `start <= end`, fewer checks are needed here
      .           /// than there are for a general `Range<usize>` (which might be `100..3`).
      .           unsafe impl<T> SliceIndex<[T]> for ops::IndexRange {
      .               type Output = [T];
      .           
      .               #[inline]
-- line 289 ----------------------------------------

192,018 ( 0.16%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/consumer/consumer.rs
--------------------------------------------------------------------------------
Ir               

-- line 6 ----------------------------------------
      .               cursor: Arc<AtomicSequence>,
      .               data_storage: Arc<D>,
      .               sequence_barrier: S,
      .               task: F,
      .               phantom_data: PhantomData<T>,
      .           }
      .           
      .           impl<T: Send, F: Task<T> + Send, D: DataStorage<T>, S: SequenceBarrier> Worker for Consumer<T, F, D, S> {
      6 ( 0.00%)      fn run(&self) {
      .                   // TODO:
      .                   // 1. get current cursor
      8 ( 0.00%)          let cursor  = self.cursor.clone();
     60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
     24 ( 0.00%)          let mut next = cursor.load() + 1;
      8 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (2x)
     78 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::load (2x)
      .                   // 2. loop
      2 ( 0.00%)          loop {
      .                       // 3. get sequence number till which i'm allowed to process using barrier
     90 ( 0.00%)              match self.sequence_barrier.wait_for(next) {
176,467 ( 0.15%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/barrier.rs:<oxidator::coordinator::barrier::DefaultSequenceBarrier<W> as oxidator::traits::traits::SequenceBarrier>::wait_for (10x)
      .                           // 4. for all slots returned, i.e. from current cursor + 1, till avaialble, run Handler business logic
     24 ( 0.00%)                  Some(upper_limit) => {
704,160 ( 0.60%)                      for i in next..=upper_limit {
4,863,912 ( 4.12%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::RangeInclusive<A>>::next (64,008x)
     64 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (8x)
     56 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:core::ops::range::RangeInclusive<Idx>::new (8x)
      .                                   unsafe {
512,000 ( 0.43%)                              let slot = self.data_storage.get_data(i);
10,304,000 ( 8.72%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/storage/ring_buffer.rs:<oxidator::storage::ring_buffer::RingBuffer<T> as oxidator::traits::traits::DataStorage<T>>::get_data (64,000x)
256,000 ( 0.22%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (64,000x)
576,000 ( 0.49%)                              self.task.execute_task(&slot, i, i == upper_limit);
16,123,904 (13.65%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:<alloc::boxed::Box<dyn oxidator::traits::traits::Task<T>+core::marker::Sync+core::marker::Send> as oxidator::traits::traits::Task<T>>::execute_task (64,000x)
      .                                   }
      .                               }
      .                               // 5. reset cursor
     48 ( 0.00%)                      cursor.store(upper_limit);
     32 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (8x)
    336 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::store (8x)
     40 ( 0.00%)                      next = upper_limit + 1;
      .                               // 6. signal to barrier, lock can be released, if any
     24 ( 0.00%)                      self.sequence_barrier.signal();
    112 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/barrier.rs:<oxidator::coordinator::barrier::DefaultSequenceBarrier<W> as oxidator::traits::traits::SequenceBarrier>::signal (8x)
      .                           }
      .                           None => {
      .                               return; // early return without updating consumer cursor
      .                           }
      .                       }
      .                   }
      8 ( 0.00%)      }
     58 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Arc<oxidator::traits::traits::AtomicSequence>> (2x)
      .           }
      .           
      .           impl<T: Default + Send + Sync + 'static, F: Task<T> + Send, D: DataStorage<T>, S: SequenceBarrier> EventConsumer<T> for Consumer<T, F, D, S> {
      .               type ConsumerWorker = Self;
      .               type Task = F;
      .               type DataStorage = D;
      .               type Barrier = S;
      .           
     14 ( 0.00%)      fn init_concurrent_task(
      .                   task: Self::Task,
      .                   barrier: Self::Barrier,
      .                   data_storage: Arc<Self::DataStorage>,
      .               ) -> Self::ConsumerWorker
      .               {
      .                   
     28 ( 0.00%)          Self {
     24 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (2x)
     30 ( 0.00%)              cursor: Arc::new(AtomicSequence::from(-1)),
    924 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T>::new (2x)
    110 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:<oxidator::traits::traits::AtomicSequence as core::convert::From<i64>>::from (2x)
     10 ( 0.00%)              task,
      6 ( 0.00%)              data_storage,
     14 ( 0.00%)              sequence_barrier: barrier,
      4 ( 0.00%)              phantom_data: PhantomData::default(),
      2 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/marker.rs:<core::marker::PhantomData<T> as core::default::Default>::default (2x)
      .                   }
      4 ( 0.00%)      }
      .           
      4 ( 0.00%)      fn get_consumer_cursor(&self) -> Arc<AtomicSequence> {
      4 ( 0.00%)          self.cursor.clone()
     60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
      4 ( 0.00%)      }
      .           }

640,132 ( 0.54%)  <counts for unidentified lines in src/consumer/consumer.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/coordinator/sequencer.rs
--------------------------------------------------------------------------------
Ir                 

-- line 127 ----------------------------------------
        .               is_done: Arc<AtomicBool>,
        .               cursor: Arc<AtomicSequence>,
        .           
        .               highest_claimed_sequence: AtomicSequence,
        .               sequence_tracker: Arc<Vec<AtomicI64>>,
        .           }
        .           
        .           impl<W: WaitStrategy> MultiProducerSequencer<W> {
        5 ( 0.00%)      pub fn new(wait_strategy: W, buffer_size: usize) -> Self {
       22 ( 0.00%)          Self {
       12 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
        3 ( 0.00%)              wait_strategy: Arc::new(wait_strategy),
      431 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T>::new (1x)
        2 ( 0.00%)              gating_sequences: Vec::new(),
        7 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T>::new (1x)
        .                       buffer_size,
       13 ( 0.00%)              is_done: Arc::new(AtomicBool::from(false)),
      439 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T>::new (1x)
        8 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:<core::sync::atomic::AtomicBool as core::convert::From<bool>>::from (1x)
        8 ( 0.00%)              cursor: Arc::new(AtomicSequence::default()),
      462 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T>::new (1x)
       63 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:<oxidator::traits::traits::AtomicSequence as core::default::Default>::default (1x)
        4 ( 0.00%)              highest_claimed_sequence: AtomicSequence::default(),
       63 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:<oxidator::traits::traits::AtomicSequence as core::default::Default>::default (1x)
   12,297 ( 0.01%)              sequence_tracker: Arc::new((0..buffer_size).map(|_| AtomicI64::new(0)).collect()),
    4,096 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::new (1,024x)
        .                   }
        2 ( 0.00%)      }
        .           
        .               pub fn get_buffer_size(&self) -> usize {
        .                   self.buffer_size
        .               }
        .           
  160,000 ( 0.14%)      fn buffer_has_capacity(&self, count: usize) -> bool {
   64,000 ( 0.05%)          if count > self.buffer_size {
        .                       return false;
        .                   }
        .           
   96,000 ( 0.08%)          if self.gating_sequences.is_empty() {
  192,000 ( 0.16%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::is_empty (32,000x)
   32,000 ( 0.03%)              return true;
        .                   }
        .           
        .                   let highest_claimed = self.highest_claimed_sequence.load();
        .                   let min_seq = min_sequence(&self.gating_sequences);
        .           
        .                   let wrap_point = min_seq + self.buffer_size as i64;
        .                   let available_slots = if highest_claimed < min_seq {
        .                       (self.buffer_size as i64) - 1
        .                   } else {
        .                       wrap_point - highest_claimed - 1
        .                   };
        .           
        .                   available_slots >= count as i64
  128,000 ( 0.11%)      }
        .           }
        .           
        .           impl<W: WaitStrategy> Clone for MultiProducerSequencer<W> {
        7 ( 0.00%)      fn clone(&self) -> Self {
       22 ( 0.00%)          Self {
       12 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
        4 ( 0.00%)              wait_strategy: self.wait_strategy.clone(),
       30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (1x)
        4 ( 0.00%)              gating_sequences: self.gating_sequences.clone(),
      385 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::clone::Clone>::clone (1x)
        2 ( 0.00%)              buffer_size: self.buffer_size,
        5 ( 0.00%)              is_done: self.is_done.clone(),
       30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (1x)
        5 ( 0.00%)              cursor: self.cursor.clone(),
       30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (1x)
        9 ( 0.00%)              highest_claimed_sequence: AtomicSequence::from(self.highest_claimed_sequence.load()),
       55 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:<oxidator::traits::traits::AtomicSequence as core::convert::From<i64>>::from (1x)
       39 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::load (1x)
        4 ( 0.00%)              sequence_tracker: self.sequence_tracker.clone(),
       30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (1x)
        .                   }
        2 ( 0.00%)      }
        .           }
        .           
        .           impl<W: WaitStrategy> Sequencer for MultiProducerSequencer<W> {
        .               type Barrier = DefaultSequenceBarrier<W>;
        .           
  192,000 ( 0.16%)      fn next(&self, count: usize) -> (Sequence, Sequence) {
        .                   loop {
  192,000 ( 0.16%)              let highest_claimed = self.highest_claimed_sequence.load();
1,248,000 ( 1.06%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::load (32,000x)
   96,000 ( 0.08%)              if self.buffer_has_capacity(count) {
  736,000 ( 0.62%)  => src/coordinator/sequencer.rs:oxidator::coordinator::sequencer::MultiProducerSequencer<W>::buffer_has_capacity (32,000x)
  160,000 ( 0.14%)                  let low = highest_claimed + 1;
  192,000 ( 0.16%)                  let high = highest_claimed + count as i64;
  128,000 ( 0.11%)                  if self.highest_claimed_sequence.compare_exchange(highest_claimed, high) {
2,784,000 ( 2.36%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::compare_exchange (32,000x)
        .                               return (low, high);
        .                           }
        .                       }
        .                   }
   64,000 ( 0.05%)      }
        .           
  160,000 ( 0.14%)      fn publish(&self, low: Sequence, high: Sequence) {
   96,000 ( 0.08%)          let buffer_size = self.buffer_size as i64;
        .           
  832,000 ( 0.70%)          for i in low..=high {
2,080,000 ( 1.76%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::RangeInclusive<A>>::next (64,000x)
  256,000 ( 0.22%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (32,000x)
  224,000 ( 0.19%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:core::ops::range::RangeInclusive<Idx>::new (32,000x)
  512,000 ( 0.43%)              let idx = (i % buffer_size) as usize;
  224,000 ( 0.19%)              if idx < self.sequence_tracker.len() {
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
   96,000 ( 0.08%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::len (32,000x)
  384,000 ( 0.32%)                  self.sequence_tracker[idx].store(1, Ordering::SeqCst);
3,584,000 ( 3.03%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index (32,000x)
1,056,000 ( 0.89%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::store (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
        .                       }
        .                   }
        .           
  192,000 ( 0.16%)          let mut current_cursor = self.cursor.load();
1,248,000 ( 1.06%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::load (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
        .           
        .                   loop {
  128,000 ( 0.11%)              let highest_claimed = self.highest_claimed_sequence.load();
1,248,000 ( 1.06%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::load (32,000x)
  192,000 ( 0.16%)              let mut next_cursor = current_cursor + 1;
   64,000 ( 0.05%)              let mut max_committable_sequence = current_cursor;
        .           
  192,000 ( 0.16%)              while next_cursor <= highest_claimed {
  544,000 ( 0.46%)                  let idx = (next_cursor % buffer_size) as usize;
  224,000 ( 0.19%)                  let tracker_value = if idx < self.sequence_tracker.len() {
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
   96,000 ( 0.08%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::len (32,000x)
  352,000 ( 0.30%)                      self.sequence_tracker[idx].load(Ordering::SeqCst)
3,584,000 ( 3.03%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
  992,000 ( 0.84%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::load (32,000x)
        .                           } else {
        .                               0
        .                           };
        .           
   64,000 ( 0.05%)                  if tracker_value == 1 {
   64,000 ( 0.05%)                      max_committable_sequence = next_cursor;
  192,000 ( 0.16%)                      next_cursor += 1;
        .                           } else {
        .                               break;
        .                           }
        .                       }
        .           
   96,000 ( 0.08%)              if max_committable_sequence > current_cursor {
  256,000 ( 0.22%)                  if self.cursor.compare_exchange(current_cursor, max_committable_sequence) {
2,784,000 ( 2.36%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/traits/traits.rs:oxidator::traits::traits::AtomicSequence::compare_exchange (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
1,056,000 ( 0.89%)                      for i in current_cursor + 1..=max_committable_sequence {
2,080,000 ( 1.76%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::RangeInclusive<A>>::next (64,000x)
  256,000 ( 0.22%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (32,000x)
  224,000 ( 0.19%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:core::ops::range::RangeInclusive<Idx>::new (32,000x)
  480,000 ( 0.41%)                          let idx = (i % buffer_size) as usize;
  224,000 ( 0.19%)                           if idx < self.sequence_tracker.len() {
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
   96,000 ( 0.08%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::len (32,000x)
  416,000 ( 0.35%)                              self.sequence_tracker[idx].store(0, Ordering::SeqCst);
3,584,000 ( 3.03%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index (32,000x)
1,056,000 ( 0.89%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::store (32,000x)
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
        .                                   }
        .                               }
  160,000 ( 0.14%)                      self.wait_strategy.signal();
  128,000 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (32,000x)
   64,000 ( 0.05%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/wait.rs:<oxidator::coordinator::wait::YieldingWaitStrategy as oxidator::traits::traits::WaitStrategy>::signal (32,000x)
        .                               break;
        .                           } else {
        .                               current_cursor = self.cursor.load();
        .                           }
        .                       } else {
        .                           self.wait_strategy.signal();
        .                           break;
        .                       }
        .                   }
   64,000 ( 0.05%)      }
        .           
       16 ( 0.00%)      fn create_barrier(&self, mut gating_sequences: Vec<Arc<AtomicSequence>>) -> Self::Barrier {
       20 ( 0.00%)          gating_sequences.push(self.cursor.clone());
      252 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push (2x)
       60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
       12 ( 0.00%)          DefaultSequenceBarrier::new(
       24 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/barrier.rs:oxidator::coordinator::barrier::DefaultSequenceBarrier<W>::new (2x)
       12 ( 0.00%)              gating_sequences,
       12 ( 0.00%)              self.wait_strategy.clone(),
       60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
        8 ( 0.00%)              self.is_done.clone(),
       60 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (2x)
        4 ( 0.00%)          )
        4 ( 0.00%)      }
        .           
        6 ( 0.00%)      fn add_gating_sequence(&mut self, gating_sequence: Arc<AtomicSequence>) {
        4 ( 0.00%)          self.gating_sequences.push(gating_sequence);
      400 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push (2x)
        4 ( 0.00%)      }
        .           
        2 ( 0.00%)      fn get_cursor(&self) -> Arc<AtomicSequence> {
        2 ( 0.00%)          self.cursor.clone()
       30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::clone::Clone>::clone (1x)
        2 ( 0.00%)      }
        .           
        3 ( 0.00%)      fn drain(&self) {
        8 ( 0.00%)          self.is_done.store(true, Ordering::SeqCst);
       39 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicBool::store (1x)
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
        4 ( 0.00%)          self.wait_strategy.signal();
        4 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:<alloc::sync::Arc<T,A> as core::ops::deref::Deref>::deref (1x)
        2 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/src/coordinator/wait.rs:<oxidator::coordinator::wait::YieldingWaitStrategy as oxidator::traits::traits::WaitStrategy>::signal (1x)
        2 ( 0.00%)      }
        .           }
        .           
        .           #[cfg(test)]
        .           mod tests_sequencer {
        .               use super::*;
        .               use crate::coordinator::{BlockingWaitStrategy, BusySpinWaitStrategy};
        .               use std::sync::Arc;
        .               use crate::traits::{AtomicSequence, Sequencer, Sequence, WaitStrategy};
-- line 285 ----------------------------------------

1,280,043 ( 1.08%)  <counts for unidentified lines in src/coordinator/sequencer.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs
--------------------------------------------------------------------------------
Ir               

-- line 414 ----------------------------------------
      .               /// # #![allow(unused_mut)]
      .               /// let mut vec: Vec<i32> = Vec::new();
      .               /// ```
      .               #[inline]
      .               #[rustc_const_stable(feature = "const_vec_new", since = "1.39.0")]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_new")]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[must_use]
     13 ( 0.00%)      pub const fn new() -> Self {
     75 ( 0.00%)          Vec { buf: RawVec::new(), len: 0 }
     13 ( 0.00%)      }
      .           
      .               /// Constructs a new, empty `Vec<T>` with at least the specified capacity.
      .               ///
      .               /// The vector will be able to hold at least `capacity` elements without
      .               /// reallocating. This method is allowed to allocate for more elements than
      .               /// `capacity`. If `capacity` is zero, the vector will not allocate.
      .               ///
      .               /// It is important to note that although the returned vector has the
-- line 432 ----------------------------------------
-- line 474 ----------------------------------------
      .               /// assert_eq!(vec_units.capacity(), usize::MAX);
      .               /// ```
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[must_use]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_with_capacity")]
      .               #[track_caller]
      8 ( 0.00%)      pub fn with_capacity(capacity: usize) -> Self {
      .                   Self::with_capacity_in(capacity, Global)
      2 ( 0.00%)      }
      .           
      .               /// Constructs a new, empty `Vec<T>` with at least the specified capacity.
      .               ///
      .               /// The vector will be able to hold at least `capacity` elements without
      .               /// reallocating. This method is allowed to allocate for more elements than
      .               /// `capacity`. If `capacity` is zero, the vector will not allocate.
      .               ///
      .               /// # Errors
-- line 492 ----------------------------------------
-- line 795 ----------------------------------------
      .               /// let vec_units = Vec::<(), System>::with_capacity_in(10, System);
      .               /// assert_eq!(vec_units.capacity(), usize::MAX);
      .               /// ```
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[unstable(feature = "allocator_api", issue = "32838")]
      .               #[track_caller]
      .               pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
      9 ( 0.00%)          Vec { buf: RawVec::with_capacity_in(capacity, alloc), len: 0 }
      .               }
      .           
      .               /// Constructs a new, empty `Vec<T, A>` with at least the specified capacity
      .               /// with the provided allocator.
      .               ///
      .               /// The vector will be able to hold at least `capacity` elements without
      .               /// reallocating. This method is allowed to allocate for more elements than
      .               /// `capacity`. If `capacity` is zero, the vector will not allocate.
-- line 811 ----------------------------------------
-- line 927 ----------------------------------------
      .               ///
      .               ///     assert_eq!(vec, &[1_000_000]);
      .               ///     assert_eq!(vec.capacity(), 16);
      .               /// }
      .               /// ```
      .               #[inline]
      .               #[unstable(feature = "allocator_api", issue = "32838")]
      .               pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -> Self {
 96,003 ( 0.08%)          unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }
      .               }
      .           
      .               #[doc(alias = "from_non_null_parts_in")]
      .               /// Creates a `Vec<T, A>` directly from a `NonNull` pointer, a length, a capacity,
      .               /// and an allocator.
      .               ///
      .               /// # Safety
      .               ///
-- line 943 ----------------------------------------
-- line 1263 ----------------------------------------
      .               /// let mut vec = vec![1];
      .               /// vec.reserve(10);
      .               /// assert!(vec.capacity() >= 11);
      .               /// ```
      .               #[cfg(not(no_global_oom_handling))]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[track_caller]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_reserve")]
      5 ( 0.00%)      pub fn reserve(&mut self, additional: usize) {
      4 ( 0.00%)          self.buf.reserve(self.len, additional);
      2 ( 0.00%)      }
      .           
      .               /// Reserves the minimum capacity for at least `additional` more elements to
      .               /// be inserted in the given `Vec<T>`. Unlike [`reserve`], this will not
      .               /// deliberately over-allocate to speculatively avoid frequent allocations.
      .               /// After calling `reserve_exact`, capacity will be greater than or equal to
      .               /// `self.len() + additional`. Does nothing if the capacity is already
      .               /// sufficient.
      .               ///
-- line 1281 ----------------------------------------
-- line 1553 ----------------------------------------
      .               /// use std::io::{self, Write};
      .               /// let buffer = vec![1, 2, 3, 5, 8];
      .               /// io::sink().write(buffer.as_slice()).unwrap();
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "vec_as_slice", since = "1.7.0")]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_as_slice")]
      .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
192,022 ( 0.16%)      pub const fn as_slice(&self) -> &[T] {
      .                   // SAFETY: `slice::from_raw_parts` requires pointee is a contiguous, aligned buffer of size
      .                   // `len` containing properly-initialized `T`s. Data must not be mutated for the returned
      .                   // lifetime. Further, `len * mem::size_of::<T>` <= `ISIZE::MAX`, and allocation does not
      .                   // "wrap" through overflowing memory addresses.
      .                   //
      .                   // * Vec API guarantees that self.buf:
      .                   //      * contains only properly-initialized items within 0..len
      .                   //      * is aligned, contiguous, and valid for `len` reads
      .                   //      * obeys size and address-wrapping constraints
      .                   //
      .                   // * We only construct `&mut` references to `self.buf` through `&mut self` methods; borrow-
      .                   //   check ensures that it is not possible to mutably alias `self.buf` within the
      .                   //   returned lifetime.
576,078 ( 0.49%)          unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }
192,022 ( 0.16%)      }
      .           
      .               /// Extracts a mutable slice of the entire vector.
      .               ///
      .               /// Equivalent to `&mut s[..]`.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
-- line 1584 ----------------------------------------
-- line 1599 ----------------------------------------
      .                   // * Vec API guarantees that self.buf:
      .                   //      * contains only properly-initialized items within 0..len
      .                   //      * is aligned, contiguous, and valid for `len` reads
      .                   //      * obeys size and address-wrapping constraints
      .                   //
      .                   // * We only construct references to `self.buf` through `&self` and `&mut self` methods;
      .                   //   borrow-check ensures that it is not possible to construct a reference to `self.buf`
      .                   //   within the returned lifetime.
      9 ( 0.00%)          unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }
      .               }
      .           
      .               /// Returns a raw pointer to the vector's buffer, or a dangling raw pointer
      .               /// valid for zero sized reads if the vector didn't allocate.
      .               ///
      .               /// The caller must ensure that the vector outlives the pointer this
      .               /// function returns, or else it will end up dangling.
      .               /// Modifying the vector may cause its buffer to be reallocated,
-- line 1615 ----------------------------------------
-- line 1663 ----------------------------------------
      .               #[stable(feature = "vec_as_ptr", since = "1.37.0")]
      .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
      .               #[rustc_never_returns_null_ptr]
      .               #[rustc_as_ptr]
      .               #[inline]
      .               pub const fn as_ptr(&self) -> *const T {
      .                   // We shadow the slice method of the same name to avoid going through
      .                   // `deref`, which creates an intermediate reference.
192,026 ( 0.16%)          self.buf.ptr()
      .               }
      .           
      .               /// Returns a raw mutable pointer to the vector's buffer, or a dangling
      .               /// raw pointer valid for zero sized reads if the vector didn't allocate.
      .               ///
      .               /// The caller must ensure that the vector outlives the pointer this
      .               /// function returns, or else it will end up dangling.
      .               /// Modifying the vector may cause its buffer to be reallocated,
-- line 1679 ----------------------------------------
-- line 1890 ----------------------------------------
      .               /// the contents and thus not leak memory.
      .               ///
      .               /// [`spare_capacity_mut()`]: Vec::spare_capacity_mut
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub unsafe fn set_len(&mut self, new_len: usize) {
      .                   debug_assert!(new_len <= self.capacity());
      .           
      1 ( 0.00%)          self.len = new_len;
      .               }
      .           
      .               /// Removes an element from the vector and returns it.
      .               ///
      .               /// The removed element is replaced by the last element of the vector.
      .               ///
      .               /// This does not preserve ordering of the remaining elements, but is *O*(1).
      .               /// If you need to preserve the element order, use [`remove`] instead.
-- line 1906 ----------------------------------------
-- line 2409 ----------------------------------------
      .               /// capacity after the push, *O*(*capacity*) time is taken to copy the
      .               /// vector's elements to a larger allocation. This expensive operation is
      .               /// offset by the *capacity* *O*(1) insertions it allows.
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_confusables("push_back", "put", "append")]
      .               #[track_caller]
  8,305 ( 0.01%)      pub fn push(&mut self, value: T) {
      .                   // Inform codegen that the length does not change across grow_one().
  3,135 ( 0.00%)          let len = self.len;
      .                   // This will panic or abort if we would allocate > isize::MAX bytes
      .                   // or if the length increment would overflow for zero-sized types.
  4,180 ( 0.00%)          if len == self.buf.capacity() {
     20 ( 0.00%)              self.buf.grow_one();
  2,814 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:alloc::raw_vec::RawVec<T,A>::grow_one (9x)
      .                   }
      .                   unsafe {
      .                       let end = self.as_mut_ptr().add(len);
  2,130 ( 0.00%)              ptr::write(end, value);
  2,090 ( 0.00%)              self.len = len + 1;
      .                   }
  2,090 ( 0.00%)      }
      .           
      .               /// Appends an element if there is sufficient spare capacity, otherwise an error is returned
      .               /// with the element.
      .               ///
      .               /// Unlike [`push`] this method will not reallocate when there's insufficient capacity.
      .               /// The caller should use [`reserve`] or [`try_reserve`] to ensure that there is enough capacity.
      .               ///
      .               /// [`push`]: Vec::push
-- line 2438 ----------------------------------------
-- line 2672 ----------------------------------------
      .               /// ```
      .               /// let a = vec![1, 2, 3];
      .               /// assert_eq!(a.len(), 3);
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
      .               #[rustc_confusables("length", "size")]
 96,011 ( 0.08%)      pub const fn len(&self) -> usize {
192,019 ( 0.16%)          let len = self.len;
      .           
      .                   // SAFETY: The maximum capacity of `Vec<T>` is `isize::MAX` bytes, so the maximum value can
      .                   // be returned is `usize::checked_div(mem::size_of::<T>()).unwrap_or(usize::MAX)`, which
      .                   // matches the definition of `T::MAX_SLICE_LEN`.
      .                   unsafe { intrinsics::assume(len <= T::MAX_SLICE_LEN) };
      .           
      .                   len
 96,011 ( 0.08%)      }
      .           
      .               /// Returns `true` if the vector contains no elements.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// let mut v = Vec::new();
      .               /// assert!(v.is_empty());
      .               ///
      .               /// v.push(1);
      .               /// assert!(!v.is_empty());
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "vec_is_empty")]
      .               #[rustc_const_unstable(feature = "const_vec_string_slice", issue = "129041")]
 32,000 ( 0.03%)      pub const fn is_empty(&self) -> bool {
 64,000 ( 0.05%)          self.len() == 0
 64,000 ( 0.05%)      }
      .           
      .               /// Splits the collection into two at the given index.
      .               ///
      .               /// Returns a newly allocated vector containing the elements in the range
      .               /// `[at, len)`. After the call, the original vector will be left containing
      .               /// the elements `[0, at)` with its previous capacity unchanged.
      .               ///
      .               /// - If you want to take ownership of the entire contents and capacity of
-- line 2715 ----------------------------------------
-- line 2874 ----------------------------------------
      .               #[stable(feature = "vec_spare_capacity", since = "1.60.0")]
      .               #[inline]
      .               pub fn spare_capacity_mut(&mut self) -> &mut [MaybeUninit<T>] {
      .                   // Note:
      .                   // This method is not implemented in terms of `split_at_spare_mut`,
      .                   // to prevent invalidation of pointers to the buffer.
      .                   unsafe {
      .                       slice::from_raw_parts_mut(
      3 ( 0.00%)                  self.as_mut_ptr().add(self.len) as *mut MaybeUninit<T>,
      6 ( 0.00%)                  self.buf.capacity() - self.len,
      .                       )
      .                   }
      .               }
      .           
      .               /// Returns vector content as a slice of `T`, along with the remaining spare
      .               /// capacity of the vector as a slice of `MaybeUninit<T>`.
      .               ///
      .               /// The returned spare capacity slice can be used to fill the vector with data
-- line 2891 ----------------------------------------
-- line 3178 ----------------------------------------
      .           // Internal methods and functions
      .           ////////////////////////////////////////////////////////////////////////////////
      .           
      .           #[doc(hidden)]
      .           #[cfg(not(no_global_oom_handling))]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[cfg_attr(not(test), rustc_diagnostic_item = "vec_from_elem")]
      .           #[track_caller]
     32 ( 0.00%)  pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {
     16 ( 0.00%)      <T as SpecFromElem>::from_elem(elem, n, Global)
  1,332 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_elem.rs:<T as alloc::vec::spec_from_elem::SpecFromElem>::from_elem (4x)
      8 ( 0.00%)  }
      .           
      .           #[doc(hidden)]
      .           #[cfg(not(no_global_oom_handling))]
      .           #[unstable(feature = "allocator_api", issue = "32838")]
      .           #[track_caller]
      .           pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {
      .               <T as SpecFromElem>::from_elem(elem, n, alloc)
      .           }
-- line 3196 ----------------------------------------
-- line 3257 ----------------------------------------
      .           // Common trait implementations for Vec
      .           ////////////////////////////////////////////////////////////////////////////////
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T, A: Allocator> ops::Deref for Vec<T, A> {
      .               type Target = [T];
      .           
      .               #[inline]
192,022 ( 0.16%)      fn deref(&self) -> &[T] {
 96,011 ( 0.08%)          self.as_slice()
8,448,968 ( 7.15%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::as_slice (96,011x)
192,022 ( 0.16%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T, A: Allocator> ops::DerefMut for Vec<T, A> {
      .               #[inline]
      .               fn deref_mut(&mut self) -> &mut [T] {
      .                   self.as_mut_slice()
      .               }
-- line 3275 ----------------------------------------
-- line 3278 ----------------------------------------
      .           #[unstable(feature = "deref_pure_trait", issue = "87121")]
      .           unsafe impl<T, A: Allocator> ops::DerefPure for Vec<T, A> {}
      .           
      .           #[cfg(not(no_global_oom_handling))]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {
      .               #[cfg(not(test))]
      .               #[track_caller]
      7 ( 0.00%)      fn clone(&self) -> Self {
      2 ( 0.00%)          let alloc = self.allocator().clone();
      2 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::alloc::Global as core::clone::Clone>::clone (1x)
      .                   <[T]>::to_vec_in(&**self, alloc)
      2 ( 0.00%)      }
      .           
      .               // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is
      .               // required for this method definition, is not available. Instead use the
      .               // `slice::to_vec` function which is only available with cfg(test)
      .               // NB see the slice::hack module in slice.rs for more information
      .               #[cfg(test)]
      .               fn clone(&self) -> Self {
      .                   let alloc = self.allocator().clone();
-- line 3297 ----------------------------------------
-- line 3349 ----------------------------------------
      .           #[rustc_on_unimplemented(
      .               message = "vector indices are of type `usize` or ranges of `usize`",
      .               label = "vector indices are of type `usize` or ranges of `usize`"
      .           )]
      .           impl<T, I: SliceIndex<[T]>, A: Allocator> Index<I> for Vec<T, A> {
      .               type Output = I::Output;
      .           
      .               #[inline]
480,030 ( 0.41%)      fn index(&self, index: I) -> &Self::Output {
      .                   Index::index(&**self, index)
192,012 ( 0.16%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           #[rustc_on_unimplemented(
      .               message = "vector indices are of type `usize` or ranges of `usize`",
      .               label = "vector indices are of type `usize` or ranges of `usize`"
      .           )]
      .           impl<T, I: SliceIndex<[T]>, A: Allocator> IndexMut<I> for Vec<T, A> {
      .               #[inline]
     15 ( 0.00%)      fn index_mut(&mut self, index: I) -> &mut Self::Output {
      .                   IndexMut::index_mut(&mut **self, index)
      6 ( 0.00%)      }
      .           }
      .           
      .           /// Collects an iterator into a Vec, commonly called via [`Iterator::collect()`]
      .           ///
      .           /// # Allocation behavior
      .           ///
      .           /// In general `Vec` does not guarantee any particular growth or allocation strategy.
      .           /// That also applies to this trait impl.
-- line 3379 ----------------------------------------
-- line 3415 ----------------------------------------
      .           ///     LONG_LIVED.lock().unwrap().push(result);
      .           /// }
      .           /// ```
      .           #[cfg(not(no_global_oom_handling))]
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T> FromIterator<T> for Vec<T> {
      .               #[inline]
      .               #[track_caller]
     12 ( 0.00%)      fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {
      6 ( 0.00%)          <Self as SpecFromIter<T, I::IntoIter>>::from_iter(iter.into_iter())
139,895 ( 0.12%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter.rs:<alloc::vec::Vec<T> as alloc::vec::spec_from_iter::SpecFromIter<T,I>>::from_iter (1x)
      5 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (1x)
      2 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T, A: Allocator> IntoIterator for Vec<T, A> {
      .               type Item = T;
      .               type IntoIter = IntoIter<T, A>;
      .           
      .               /// Creates a consuming iterator, that is, one that moves each value out of
-- line 3433 ----------------------------------------
-- line 3442 ----------------------------------------
      .               ///
      .               /// let first_element: Option<String> = v_iter.next();
      .               ///
      .               /// assert_eq!(first_element, Some("a".to_string()));
      .               /// assert_eq!(v_iter.next(), Some("b".to_string()));
      .               /// assert_eq!(v_iter.next(), None);
      .               /// ```
      .               #[inline]
 96,012 ( 0.08%)      fn into_iter(self) -> Self::IntoIter {
      .                   unsafe {
      .                       let me = ManuallyDrop::new(self);
160,020 ( 0.14%)              let alloc = ManuallyDrop::new(ptr::read(me.allocator()));
128,016 ( 0.11%)              let buf = me.buf.non_null();
      .                       let begin = buf.as_ptr();
      .                       let end = if T::IS_ZST {
      .                           begin.wrapping_byte_add(me.len())
      .                       } else {
 96,012 ( 0.08%)                  begin.add(me.len()) as *const T
      .                       };
128,016 ( 0.11%)              let cap = me.buf.capacity();
192,024 ( 0.16%)              IntoIter { buf, phantom: PhantomData, cap, alloc, ptr: buf, end }
      .                   }
 64,008 ( 0.05%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<'a, T, A: Allocator> IntoIterator for &'a Vec<T, A> {
      .               type Item = &'a T;
      .               type IntoIter = slice::Iter<'a, T>;
      .           
     16 ( 0.00%)      fn into_iter(self) -> Self::IntoIter {
      .                   self.iter()
     16 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<'a, T, A: Allocator> IntoIterator for &'a mut Vec<T, A> {
      .               type Item = &'a mut T;
      .               type IntoIter = slice::IterMut<'a, T>;
      .           
      .               fn into_iter(self) -> Self::IntoIter {
-- line 3482 ----------------------------------------
-- line 3544 ----------------------------------------
      .                       }
      .                   }
      .               }
      .           
      .               // specific extend for `TrustedLen` iterators, called both by the specializations
      .               // and internal places where resolving specialization makes compilation slower
      .               #[cfg(not(no_global_oom_handling))]
      .               #[track_caller]
      6 ( 0.00%)      fn extend_trusted(&mut self, iterator: impl iter::TrustedLen<Item = T>) {
     11 ( 0.00%)          let (low, high) = iterator.size_hint();
     52 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::size_hint (1x)
      4 ( 0.00%)          if let Some(additional) = high {
      1 ( 0.00%)              debug_assert_eq!(
      .                           low,
      .                           additional,
      .                           "TrustedLen iterator's size hint is not exact: {:?}",
      .                           (low, high)
      .                       );
      2 ( 0.00%)              self.reserve(additional);
     30 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::reserve (1x)
      .                       unsafe {
      .                           let ptr = self.as_mut_ptr();
      3 ( 0.00%)                  let mut local_len = SetLenOnDrop::new(&mut self.len);
  4,105 ( 0.00%)                  iterator.for_each(move |element| {
139,358 ( 0.12%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:core::iter::traits::iterator::Iterator::for_each (1x)
  1,024 ( 0.00%)                      ptr::write(ptr.add(local_len.current_len()), element);
      .                               // Since the loop executes user code which can panic we have to update
      .                               // the length every step to correctly drop what we've written.
      .                               // NB can't overflow since we would have had to alloc the address space
      .                               local_len.increment_len(1);
  1,024 ( 0.00%)                  });
      .                       }
      .                   } else {
      .                       // Per TrustedLen contract a `None` upper bound means that the iterator length
      .                       // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.
      .                       // Since the other branch already panics eagerly (via `reserve()`) we do the same here.
      .                       // This avoids additional codegen for a fallback code path which would eventually
      .                       // panic anyway.
      .                       panic!("capacity overflow");
      .                   }
      2 ( 0.00%)      }
      .           
      .               /// Creates a splicing iterator that replaces the specified range in the vector
      .               /// with the given `replace_with` iterator and yields the removed items.
      .               /// `replace_with` does not need to be the same length as `range`.
      .               ///
      .               /// `range` is removed even if the `Splice` iterator is not consumed before it is dropped.
      .               ///
      .               /// It is unspecified how many elements are removed from the vector
-- line 3589 ----------------------------------------
-- line 3773 ----------------------------------------
      .               #[inline]
      .               fn cmp(&self, other: &Self) -> Ordering {
      .                   Ord::cmp(&**self, &**other)
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {
     37 ( 0.00%)      fn drop(&mut self) {
      .                   unsafe {
      .                       // use drop for [T]
      .                       // use a raw slice to refer to the elements of the vector as weakest necessary type;
      .                       // could avoid questions of validity in certain cases
     47 ( 0.00%)              ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
  2,464 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[oxidator::producer::producer::Producer<multi_producer::Event,oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>,oxidator::storage::ring_buffer::RingBuffer<multi_producer::Event>>]> (1x)
    857 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[alloc::boxed::Box<dyn oxidator::traits::traits::Task<multi_producer::Event>>]> (1x)
    317 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[alloc::sync::Arc<oxidator::traits::traits::AtomicSequence>]> (4x)
     22 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[std::thread::JoinHandle<()>]> (2x)
      .                   }
      .                   // RawVec handles deallocation
     28 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T> Default for Vec<T> {
      .               /// Creates an empty `Vec<T>`.
      .               ///
      .               /// The vector will not allocate until elements are pushed onto it.
      2 ( 0.00%)      fn default() -> Vec<T> {
      .                   Vec::new()
      2 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: fmt::Debug, A: Allocator> fmt::Debug for Vec<T, A> {
      .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      .                   fmt::Debug::fmt(&**self, f)
      .               }
      .           }
-- line 3807 ----------------------------------------

388,225 ( 0.33%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs
--------------------------------------------------------------------------------
Ir               

-- line 100 ----------------------------------------
      .           // reads/writes to this flag.
      .           //
      .           // As a result, if it matters, we should see the correct value for `failed` in
      .           // all cases.
      .           
      .           impl Flag {
      .               #[inline]
      .               pub const fn new() -> Flag {
      2 ( 0.00%)          Flag {
      .                       #[cfg(panic = "unwind")]
      .                       failed: AtomicBool::new(false),
      .                   }
      .               }
      .           
      .               /// Checks the flag for an unguarded borrow, where we only care about existing poison.
      .               #[inline]
      .               pub fn borrow(&self) -> LockResult<()> {
      .                   if self.get() { Err(PoisonError::new(())) } else { Ok(()) }
      .               }
      .           
      .               /// Checks the flag for a guarded borrow, where we may also set poison when `done`.
      .               #[inline]
 96,009 ( 0.08%)      pub fn guard(&self) -> LockResult<Guard> {
 64,006 ( 0.05%)          let ret = Guard {
      .                       #[cfg(panic = "unwind")]
      .                       panicking: thread::panicking(),
      .                   };
192,018 ( 0.16%)          if self.get() { Err(PoisonError::new(ret)) } else { Ok(ret) }
128,012 ( 0.11%)      }
      .           
      .               #[inline]
      .               #[cfg(panic = "unwind")]
128,012 ( 0.11%)      pub fn done(&self, guard: &Guard) {
 96,009 ( 0.08%)          if !guard.panicking && thread::panicking() {
      .                       self.failed.store(true, Ordering::Relaxed);
      .                   }
 64,006 ( 0.05%)      }
      .           
      .               #[inline]
      .               #[cfg(not(panic = "unwind"))]
      .               pub fn done(&self, _guard: &Guard) {}
      .           
      .               #[inline]
      .               #[cfg(panic = "unwind")]
      .               pub fn get(&self) -> bool {
 32,003 ( 0.03%)          self.failed.load(Ordering::Relaxed)
      .               }
      .           
      .               #[inline(always)]
      .               #[cfg(not(panic = "unwind"))]
      .               pub fn get(&self) -> bool {
      .                   false
      .               }
      .           
-- line 153 ----------------------------------------
-- line 392 ----------------------------------------
      .                       TryLockError::Poisoned(ref p) => Some(p),
      .                       #[cfg(not(panic = "unwind"))]
      .                       TryLockError::Poisoned(ref p) => match p._never {},
      .                       _ => None,
      .                   }
      .               }
      .           }
      .           
320,030 ( 0.27%)  pub(crate) fn map_result<T, U, F>(result: LockResult<T>, f: F) -> LockResult<U>
      .           where
      .               F: FnOnce(T) -> U,
      .           {
160,015 ( 0.14%)      match result {
448,042 ( 0.38%)          Ok(t) => Ok(f(t)),
224,021 ( 0.19%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:std::sync::poison::mutex::MutexGuard<T>::new::{{closure}} (32,003x)
      .                   #[cfg(panic = "unwind")]
      .                   Err(PoisonError { data }) => Err(PoisonError::new(f(data))),
      .               }
 64,006 ( 0.05%)  }

 96,009 ( 0.08%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs
--------------------------------------------------------------------------------
Ir               

-- line 274 ----------------------------------------
      .               #[inline]
      .               fn into_inner_with_allocator(this: Self) -> (NonNull<ArcInner<T>>, A) {
      .                   let this = mem::ManuallyDrop::new(this);
      .                   (this.ptr, unsafe { ptr::read(&this.alloc) })
      .               }
      .           
      .               #[inline]
      .               unsafe fn from_inner_in(ptr: NonNull<ArcInner<T>>, alloc: A) -> Self {
     18 ( 0.00%)          Self { ptr, phantom: PhantomData, alloc }
      .               }
      .           
      .               #[inline]
      .               unsafe fn from_ptr_in(ptr: *mut ArcInner<T>, alloc: A) -> Self {
      .                   unsafe { Self::from_inner_in(NonNull::new_unchecked(ptr), alloc) }
      .               }
      .           }
      .           
-- line 290 ----------------------------------------
-- line 378 ----------------------------------------
      .               /// ```
      .               /// use std::sync::Arc;
      .               ///
      .               /// let five = Arc::new(5);
      .               /// ```
      .               #[cfg(not(no_global_oom_handling))]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
     19 ( 0.00%)      pub fn new(data: T) -> Arc<T> {
      .                   // Start the weak pointer count as 1 which is the weak pointer that's
      .                   // held by all the strong pointers (kinda), see std/rc.rs for more info
    184 ( 0.00%)          let x: Box<_> = Box::new(ArcInner {
     30 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
      .                       strong: atomic::AtomicUsize::new(1),
      .                       weak: atomic::AtomicUsize::new(1),
      .                       data,
      .                   });
     16 ( 0.00%)          unsafe { Self::from_inner(Box::leak(x).into()) }
     20 ( 0.00%)      }
      .           
      .               /// Constructs a new `Arc<T>` while giving you a `Weak<T>` to the allocation,
      .               /// to allow you to construct a `T` which holds a weak pointer to itself.
      .               ///
      .               /// Generally, a structure circularly referencing itself, either directly or
      .               /// indirectly, should not hold a strong reference to itself to prevent a memory leak.
      .               /// Using this function, you get access to the weak pointer during the
      .               /// initialization of `T`, before the `Arc<T>` is created, such that you can
-- line 403 ----------------------------------------
-- line 1891 ----------------------------------------
      .                   // `ArcInner` structure itself is `Sync` because the inner data is
      .                   // `Sync` as well, so we're ok loaning out an immutable pointer to these
      .                   // contents.
      .                   unsafe { self.ptr.as_ref() }
      .               }
      .           
      .               // Non-inlined part of `drop`.
      .               #[inline(never)]
     32 ( 0.00%)      unsafe fn drop_slow(&mut self) {
      .                   // Drop the weak ref collectively held by all strong references when this
      .                   // variable goes out of scope. This ensures that the memory is deallocated
      .                   // even if the destructor of `T` panics.
      .                   // Take a reference to `self.alloc` instead of cloning because 1. it'll last long
      .                   // enough, and 2. you should be able to drop `Arc`s with unclonable allocators
     80 ( 0.00%)          let _weak = Weak { ptr: self.ptr, alloc: &self.alloc };
      .           
      .                   // Destroy the data at this time, even though we must not free the box
      .                   // allocation itself (there might still be weak pointers lying around).
      .                   // We cannot use `get_mut_unchecked` here, because `self.alloc` is borrowed.
     65 ( 0.00%)          unsafe { ptr::drop_in_place(&mut (*self.ptr.as_ptr()).data) };
  1,384 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>> (1x)
    948 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<std::thread::Packet<()>> (6x)
    235 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<oxidator::storage::ring_buffer::RingBuffer<multi_producer::Event>> (1x)
     64 ( 0.00%)      }
  1,432 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Weak<std::thread::Packet<()>,&alloc::alloc::Global>> (6x)
    448 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Weak<oxidator::traits::traits::AtomicSequence,&alloc::alloc::Global>> (2x)
    254 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Weak<oxidator::storage::ring_buffer::RingBuffer<multi_producer::Event>,&alloc::alloc::Global>> (1x)
    224 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Weak<std::sync::poison::mutex::Mutex<multi_producer::EventCounters>,&alloc::alloc::Global>> (1x)
    224 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Weak<oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>,&alloc::alloc::Global>> (1x)
    224 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::sync::Weak<core::sync::atomic::AtomicI32,&alloc::alloc::Global>> (1x)
      .           
      .               /// Returns `true` if the two `Arc`s point to the same allocation in a vein similar to
      .               /// [`ptr::eq`]. This function ignores the metadata of  `dyn Trait` pointers.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// use std::sync::Arc;
-- line 1919 ----------------------------------------
-- line 2155 ----------------------------------------
      .               /// ```
      .               /// use std::sync::Arc;
      .               ///
      .               /// let five = Arc::new(5);
      .               ///
      .               /// let _ = Arc::clone(&five);
      .               /// ```
      .               #[inline]
    120 ( 0.00%)      fn clone(&self) -> Arc<T, A> {
      .                   // Using a relaxed ordering is alright here, as knowledge of the
      .                   // original reference prevents other threads from erroneously deleting
      .                   // the object.
      .                   //
      .                   // As explained in the [Boost documentation][1], Increasing the
      .                   // reference counter can always be done with memory_order_relaxed: New
      .                   // references to an object can only be formed from an existing
      .                   // reference, and passing an existing reference from one thread to
      .                   // another must already provide any required synchronization.
      .                   //
      .                   // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
     58 ( 0.00%)          let old_size = self.inner().strong.fetch_add(1, Relaxed);
      .           
      .                   // However we need to guard against massive refcounts in case someone is `mem::forget`ing
      .                   // Arcs. If we don't do this the count can overflow and users will use-after free. This
      .                   // branch will never be taken in any realistic program. We abort because such a program is
      .                   // incredibly degenerate, and we don't care to support it.
      .                   //
      .                   // This check is not 100% water-proof: we error when the refcount grows beyond `isize::MAX`.
      .                   // But we do that check *after* having done the increment, so there is a chance here that
-- line 2183 ----------------------------------------
-- line 2184 ----------------------------------------
      .                   // the worst already happened and we actually do overflow the `usize` counter. However, that
      .                   // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment
      .                   // above and the `abort` below, which seems exceedingly unlikely.
      .                   //
      .                   // This is a global invariant, and also applies when using a compare-exchange loop to increment
      .                   // counters in other methods.
      .                   // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,
      .                   // and then overflow using a few `fetch_add`s.
    174 ( 0.00%)          if old_size > MAX_REFCOUNT {
      .                       abort();
      .                   }
      .           
    318 ( 0.00%)          unsafe { Self::from_inner_in(self.ptr, self.alloc.clone()) }
     80 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::alloc::Global as core::clone::Clone>::clone (40x)
     80 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: ?Sized, A: Allocator> Deref for Arc<T, A> {
      .               type Target = T;
      .           
      .               #[inline]
512,350 ( 0.43%)      fn deref(&self) -> &T {
512,973 ( 0.43%)          &self.inner().data
512,350 ( 0.43%)      }
      .           }
      .           
      .           #[unstable(feature = "pin_coerce_unsized_trait", issue = "123430")]
      .           unsafe impl<T: ?Sized, A: Allocator> PinCoerceUnsized for Arc<T, A> {}
      .           
      .           #[unstable(feature = "pin_coerce_unsized_trait", issue = "123430")]
      .           unsafe impl<T: ?Sized, A: Allocator> PinCoerceUnsized for Weak<T, A> {}
      .           
-- line 2215 ----------------------------------------
-- line 2405 ----------------------------------------
      .               /// assert_eq!(*x, 4);
      .               ///
      .               /// let _y = Arc::clone(&x);
      .               /// assert!(Arc::get_mut(&mut x).is_none());
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "arc_unique", since = "1.4.0")]
      .               pub fn get_mut(this: &mut Self) -> Option<&mut T> {
     36 ( 0.00%)          if this.is_unique() {
    954 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T,A>::is_unique (6x)
      .                       // This unsafety is ok because we're guaranteed that the pointer
      .                       // returned is the *only* pointer that will ever be returned to T. Our
      .                       // reference count is guaranteed to be 1 at this point, and we required
      .                       // the Arc itself to be `mut`, so we're returning the only possible
      .                       // reference to the inner data.
      6 ( 0.00%)              unsafe { Some(Arc::get_mut_unchecked(this)) }
      .                   } else {
      .                       None
      .                   }
      .               }
      .           
      .               /// Returns a mutable reference into the given `Arc`,
      .               /// without any check.
      .               ///
-- line 2427 ----------------------------------------
-- line 2482 ----------------------------------------
      .               /// }
      .               /// println!("{}", &*x); // Use-after-free
      .               /// ```
      .               #[inline]
      .               #[unstable(feature = "get_mut_unchecked", issue = "63292")]
      .               pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
      .                   // We are careful to *not* create a reference covering the "count" fields, as
      .                   // this would alias with concurrent access to the reference counts (e.g. by `Weak`).
     12 ( 0.00%)          unsafe { &mut (*this.ptr.as_ptr()).data }
      .               }
      .           
      .               /// Determine whether this is the unique reference (including weak refs) to
      .               /// the underlying data.
      .               ///
      .               /// Note that this requires locking the weak ref count.
     18 ( 0.00%)      fn is_unique(&mut self) -> bool {
      .                   // lock the weak pointer count if we appear to be the sole weak pointer
      .                   // holder.
      .                   //
      .                   // The acquire label here ensures a happens-before relationship with any
      .                   // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements
      .                   // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded
      .                   // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.
     48 ( 0.00%)          if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {
      .                       // This needs to be an `Acquire` to synchronize with the decrement of the `strong`
      .                       // counter in `drop` -- the only access that happens when any but the last reference
      .                       // is being dropped.
     36 ( 0.00%)              let unique = self.inner().strong.load(Acquire) == 1;
      .           
      .                       // The release write here synchronizes with a read in `downgrade`,
      .                       // effectively preventing the above read of `strong` from happening
      .                       // after the write.
     18 ( 0.00%)              self.inner().weak.store(1, Release); // release the lock
     12 ( 0.00%)              unique
      .                   } else {
      .                       false
      .                   }
     24 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Arc<T, A> {
      .               /// Drops the `Arc`.
      .               ///
      .               /// This will decrement the strong reference count. If the strong reference
      .               /// count reaches zero then the only other references (if any) are
-- line 2527 ----------------------------------------
-- line 2542 ----------------------------------------
      .               ///
      .               /// let foo  = Arc::new(Foo);
      .               /// let foo2 = Arc::clone(&foo);
      .               ///
      .               /// drop(foo);    // Doesn't print anything
      .               /// drop(foo2);   // Prints "dropped!"
      .               /// ```
      .               #[inline]
    222 ( 0.00%)      fn drop(&mut self) {
      .                   // Because `fetch_sub` is already atomic, we do not need to synchronize
      .                   // with other threads unless we are going to delete the object. This
      .                   // same logic applies to the below `fetch_sub` to the `weak` count.
    222 ( 0.00%)          if self.inner().strong.fetch_sub(1, Release) != 1 {
      .                       return;
      .                   }
      .           
      .                   // This fence is needed to prevent reordering of use of the data and
      .                   // deletion of the data. Because it is marked `Release`, the decreasing
      .                   // of the reference count synchronizes with this `Acquire` fence. This
      .                   // means that use of the data happens before decreasing the reference
      .                   // count, which happens before this fence, which happens before the
-- line 2562 ----------------------------------------
-- line 2589 ----------------------------------------
      .                   // used by Default::default.
      .                   debug_assert!(
      .                       !ptr::addr_eq(self.ptr.as_ptr(), &STATIC_INNER_SLICE.inner),
      .                       "Arcs backed by a static should never reach a strong count of 0. \
      .                       Likely decrement_strong_count or from_raw were called too many times.",
      .                   );
      .           
      .                   unsafe {
     44 ( 0.00%)              self.drop_slow();
  5,559 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:alloc::sync::Arc<T,A>::drop_slow (12x)
    714 ( 0.00%)  => /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/alloc/src/sync.rs:alloc::sync::Arc<T,A>::drop_slow (6x)
      .                   }
    200 ( 0.00%)      }
      .           }
      .           
      .           impl<A: Allocator> Arc<dyn Any + Send + Sync, A> {
      .               /// Attempts to downcast the `Arc<dyn Any + Send + Sync>` to a concrete type.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
-- line 2607 ----------------------------------------
-- line 3061 ----------------------------------------
      .                       0
      .                   }
      .               }
      .           
      .               /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,
      .               /// (i.e., when this `Weak` was created by `Weak::new`).
      .               #[inline]
      .               fn inner(&self) -> Option<WeakInner<'_>> {
     48 ( 0.00%)          let ptr = self.ptr.as_ptr();
     32 ( 0.00%)          if is_dangling(ptr) {
      .                       None
      .                   } else {
      .                       // We are careful to *not* create a reference covering the "data" field, as
      .                       // the field may be mutated concurrently (for example, if the last `Arc`
      .                       // is dropped, the data field will be dropped in-place).
     64 ( 0.00%)              Some(unsafe { WeakInner { strong: &(*ptr).strong, weak: &(*ptr).weak } })
      .                   }
      .               }
      .           
      .               /// Returns `true` if the two `Weak`s point to the same allocation similar to [`ptr::eq`], or if
      .               /// both don't point to any allocation (because they were created with `Weak::new()`). However,
      .               /// this function ignores the metadata of  `dyn Trait` pointers.
      .               ///
      .               /// # Notes
-- line 3084 ----------------------------------------
-- line 3200 ----------------------------------------
      .               /// let weak_foo = Arc::downgrade(&foo);
      .               /// let other_weak_foo = Weak::clone(&weak_foo);
      .               ///
      .               /// drop(weak_foo);   // Doesn't print anything
      .               /// drop(foo);        // Prints "dropped!"
      .               ///
      .               /// assert!(other_weak_foo.upgrade().is_none());
      .               /// ```
     48 ( 0.00%)      fn drop(&mut self) {
      .                   // If we find out that we were the last weak pointer, then its time to
      .                   // deallocate the data entirely. See the discussion in Arc::drop() about
      .                   // the memory orderings
      .                   //
      .                   // It's not necessary to check for the locked state here, because the
      .                   // weak count can only be locked if there was precisely one weak ref,
      .                   // meaning that drop could only subsequently run ON that remaining weak
      .                   // ref, which can only happen after the lock is released.
     64 ( 0.00%)          let inner = if let Some(inner) = self.inner() { inner } else { return };
      .           
     32 ( 0.00%)          if inner.weak.fetch_sub(1, Release) == 1 {
      .                       acquire!(inner.weak);
      .           
      .                       // Make sure we aren't trying to "deallocate" the shared static for empty slices
      .                       // used by Default::default.
      .                       debug_assert!(
      .                           !ptr::addr_eq(self.ptr.as_ptr(), &STATIC_INNER_SLICE.inner),
      .                           "Arc/Weaks backed by a static should never be deallocated. \
      .                           Likely decrement_strong_count or from_raw were called too many times.",
      .                       );
      .           
      .                       unsafe {
    160 ( 0.00%)                  self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()))
  2,182 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/mod.rs:<&A as core::alloc::Allocator>::deallocate (16x)
      .                       }
      .                   }
     48 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           trait ArcEqIdent<T: ?Sized + PartialEq, A: Allocator> {
      .               fn eq(&self, other: &Arc<T, A>) -> bool;
      .               fn ne(&self, other: &Arc<T, A>) -> bool;
      .           }
      .           
-- line 3242 ----------------------------------------
-- line 3909 ----------------------------------------
      .           impl<T: ?Sized, A: Allocator> borrow::Borrow<T> for Arc<T, A> {
      .               fn borrow(&self) -> &T {
      .                   &**self
      .               }
      .           }
      .           
      .           #[stable(since = "1.5.0", feature = "smart_ptr_as_ref")]
      .           impl<T: ?Sized, A: Allocator> AsRef<T> for Arc<T, A> {
    623 ( 0.00%)      fn as_ref(&self) -> &T {
      .                   &**self
    623 ( 0.00%)      }
      .           }
      .           
      .           #[stable(feature = "pin", since = "1.33.0")]
      .           impl<T: ?Sized, A: Allocator> Unpin for Arc<T, A> {}
      .           
      .           /// Gets the offset within an `ArcInner` for the payload behind a pointer.
      .           ///
      .           /// # Safety
-- line 3927 ----------------------------------------

    156 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs
--------------------------------------------------------------------------------
Ir               

-- line 990 ----------------------------------------
      .               /// }
      .               ///
      .               /// assert_eq!(Equal("self").max(Equal("other")).0, "other");
      .               /// ```
      .               #[stable(feature = "ord_max_min", since = "1.21.0")]
      .               #[inline]
      .               #[must_use]
      .               #[rustc_diagnostic_item = "cmp_ord_max"]
      2 ( 0.00%)      fn max(self, other: Self) -> Self
      .               where
      .                   Self: Sized,
      .               {
     10 ( 0.00%)          if other < self { self } else { other }
      5 ( 0.00%)      }
      .           
      .               /// Compares and returns the minimum of two values.
      .               ///
      .               /// Returns the first argument if the comparison determines them to be equal.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
-- line 1011 ----------------------------------------
-- line 1494 ----------------------------------------
      .           /// assert_eq!(result, 2);
      .           ///
      .           /// let result = cmp::min_by(1, -1, abs_cmp);
      .           /// assert_eq!(result, 1);
      .           /// ```
      .           #[inline]
      .           #[must_use]
      .           #[stable(feature = "cmp_min_max_by", since = "1.53.0")]
  2,107 ( 0.00%)  pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {
  3,612 ( 0.00%)      if compare(&v2, &v1).is_lt() { v2 } else { v1 }
  9,030 ( 0.01%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &mut F>::call_once (301x)
    903 ( 0.00%)  }
      .           
      .           /// Returns the element that gives the minimum value from the specified function.
      .           ///
      .           /// Returns the first argument if the comparison determines them to be equal.
      .           ///
      .           /// # Examples
      .           ///
      .           /// ```
-- line 1512 ----------------------------------------
-- line 1732 ----------------------------------------
      .               use crate::cmp::Ordering::{self, Equal, Greater, Less};
      .               use crate::hint::unreachable_unchecked;
      .           
      .               macro_rules! partial_eq_impl {
      .                   ($($t:ty)*) => ($(
      .                       #[stable(feature = "rust1", since = "1.0.0")]
      .                       impl PartialEq for $t {
      .                           #[inline]
320,041 ( 0.27%)                  fn eq(&self, other: &$t) -> bool { (*self) == (*other) }
      .                           #[inline]
      .                           fn ne(&self, other: &$t) -> bool { (*self) != (*other) }
      .                       }
      .                   )*)
      .               }
      .           
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               impl PartialEq for () {
-- line 1748 ----------------------------------------
-- line 1816 ----------------------------------------
      .                   ($($t:ty)*) => ($(
      .                       #[stable(feature = "rust1", since = "1.0.0")]
      .                       impl PartialOrd for $t {
      .                           #[inline]
      .                           fn partial_cmp(&self, other: &$t) -> Option<Ordering> {
      .                               Some(crate::intrinsics::three_way_compare(*self, *other))
      .                           }
      .                           #[inline(always)]
452,146 ( 0.38%)                  fn lt(&self, other: &$t) -> bool { (*self) < (*other) }
      .                           #[inline(always)]
384,000 ( 0.32%)                  fn le(&self, other: &$t) -> bool { (*self) <= (*other) }
      .                           #[inline(always)]
      .                           fn ge(&self, other: &$t) -> bool { (*self) >= (*other) }
      .                           #[inline(always)]
      .                           fn gt(&self, other: &$t) -> bool { (*self) > (*other) }
      .                       }
      .           
      .                       #[stable(feature = "rust1", since = "1.0.0")]
      .                       impl Ord for $t {
      .                           #[inline]
    602 ( 0.00%)                  fn cmp(&self, other: &$t) -> Ordering {
  2,709 ( 0.00%)                      crate::intrinsics::three_way_compare(*self, *other)
    301 ( 0.00%)                  }
      .                       }
      .                   )*)
      .               }
      .           
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               impl Ord for () {
      .                   #[inline]
      .                   fn cmp(&self, _other: &()) -> Ordering {
-- line 1846 ----------------------------------------
-- line 1914 ----------------------------------------
      .           
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A
      .               where
      .                   A: PartialEq<B>,
      .               {
      .                   #[inline]
      .                   fn eq(&self, other: &&B) -> bool {
      9 ( 0.00%)              PartialEq::eq(*self, *other)
     21 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:core::cmp::impls::<impl core::cmp::PartialEq for usize>::eq (3x)
      .                   }
      .                   #[inline]
      .                   fn ne(&self, other: &&B) -> bool {
      .                       PartialEq::ne(*self, *other)
      .                   }
      .               }
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A
-- line 1930 ----------------------------------------

    302 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs
--------------------------------------------------------------------------------
Ir               

-- line 539 ----------------------------------------
      .                   /// ```
      .                   #[stable(feature = "mixed_integer_ops", since = "1.66.0")]
      .                   #[rustc_const_stable(feature = "mixed_integer_ops", since = "1.66.0")]
      .                   #[must_use = "this returns the result of the operation, \
      .                                 without modifying the original"]
      .                   #[inline]
      .                   pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {
      .                       let (a, b) = self.overflowing_add_unsigned(rhs);
127,984 ( 0.11%)              if intrinsics::unlikely(b) { None } else { Some(a) }
      .                   }
      .           
      .                   /// Strict addition with an unsigned integer. Computes `self + rhs`,
      .                   /// panicking if overflow occurred.
      .                   ///
      .                   /// # Panics
      .                   ///
      .                   /// ## Overflow behavior
-- line 555 ----------------------------------------
-- line 2099 ----------------------------------------
      .                   #[doc = concat!("assert_eq!((-100", stringify!($SelfT), ").wrapping_neg(), 100);")]
      .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MIN.wrapping_neg(), ", stringify!($SelfT), "::MIN);")]
      .                   /// ```
      .                   #[stable(feature = "num_wrapping", since = "1.2.0")]
      .                   #[rustc_const_stable(feature = "const_int_methods", since = "1.32.0")]
      .                   #[must_use = "this returns the result of the operation, \
      .                                 without modifying the original"]
      .                   #[inline(always)]
 64,012 ( 0.05%)          pub const fn wrapping_neg(self) -> Self {
      .                       (0 as $SelfT).wrapping_sub(self)
      .                   }
      .           
      .                   /// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes
      .                   /// any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.
      .                   ///
      .                   /// Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to
      .                   /// the range of the type, rather than the bits shifted out of the LHS being returned to the other end.
-- line 2115 ----------------------------------------
-- line 2290 ----------------------------------------
      .                   #[doc = concat!("assert_eq!(", stringify!($SelfT), "::MAX.overflowing_add(1), (", stringify!($SelfT), "::MIN, true));")]
      .                   /// ```
      .                   #[stable(feature = "wrapping", since = "1.7.0")]
      .                   #[rustc_const_stable(feature = "const_int_methods", since = "1.32.0")]
      .                   #[must_use = "this returns the result of the operation, \
      .                                 without modifying the original"]
      .                   #[inline(always)]
      .                   pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
255,968 ( 0.22%)              let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);
      .                       (a as Self, b)
      .                   }
      .           
      .                   /// Calculates `self` + `rhs` + `carry` and checks for overflow.
      .                   ///
      .                   /// Performs "ternary addition" of two integer operands and a carry-in
      .                   /// bit, and returns a tuple of the sum along with a boolean indicating
      .                   /// whether an arithmetic overflow would occur. On overflow, the wrapped
-- line 2306 ----------------------------------------
-- line 2374 ----------------------------------------
      .                   #[stable(feature = "mixed_integer_ops", since = "1.66.0")]
      .                   #[rustc_const_stable(feature = "mixed_integer_ops", since = "1.66.0")]
      .                   #[must_use = "this returns the result of the operation, \
      .                                 without modifying the original"]
      .                   #[inline]
      .                   pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {
      .                       let rhs = rhs as Self;
      .                       let (res, overflowed) = self.overflowing_add(rhs);
383,952 ( 0.32%)              (res, overflowed ^ (rhs < 0))
      .                   }
      .           
      .                   /// Calculates `self` - `rhs`.
      .                   ///
      .                   /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow
      .                   /// would occur. If an overflow would have occurred then the wrapped value is returned.
      .                   ///
      .                   /// # Examples
-- line 2390 ----------------------------------------
-- line 3441 ----------------------------------------
      .                   /// ```
      .                   #[stable(feature = "rust1", since = "1.0.0")]
      .                   #[rustc_const_stable(feature = "const_int_methods", since = "1.32.0")]
      .                   #[allow(unused_attributes)]
      .                   #[must_use = "this returns the result of the operation, \
      .                                 without modifying the original"]
      .                   #[inline]
      .                   #[rustc_inherit_overflow_checks]
     18 ( 0.00%)          pub const fn abs(self) -> Self {
      .                       // Note that the #[rustc_inherit_overflow_checks] and #[inline]
      .                       // above mean that the overflow semantics of the subtraction
      .                       // depend on the crate we're being called from.
     12 ( 0.00%)              if self.is_negative() {
     28 ( 0.00%)                  -self
      .                       } else {
      2 ( 0.00%)                  self
      .                       }
     18 ( 0.00%)          }
      .           
      .                   /// Computes the absolute difference between `self` and `other`.
      .                   ///
      .                   /// This function always returns the correct answer without overflow or
      .                   /// panics by returning an unsigned integer.
      .                   ///
      .                   /// # Examples
      .                   ///
-- line 3466 ----------------------------------------
-- line 3558 ----------------------------------------
      .                   /// ```
      .                   #[doc = concat!("assert!((-10", stringify!($SelfT), ").is_negative());")]
      .                   #[doc = concat!("assert!(!10", stringify!($SelfT), ".is_negative());")]
      .                   /// ```
      .                   #[must_use]
      .                   #[stable(feature = "rust1", since = "1.0.0")]
      .                   #[rustc_const_stable(feature = "const_int_methods", since = "1.32.0")]
      .                   #[inline(always)]
      6 ( 0.00%)          pub const fn is_negative(self) -> bool { self < 0 }
      .           
      .                   /// Returns the memory representation of this integer as a byte array in
      .                   /// big-endian (network) byte order.
      .                   ///
      .                   #[doc = $to_xe_bytes_doc]
      .                   ///
      .                   /// # Examples
      .                   ///
-- line 3574 ----------------------------------------

     10 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs
--------------------------------------------------------------------------------
Ir                 

-- line 592 ----------------------------------------
        .               args: &'a [rt::Argument<'a>],
        .           }
        .           
        .           /// Used by the format_args!() macro to create a fmt::Arguments object.
        .           #[doc(hidden)]
        .           #[unstable(feature = "fmt_internals", issue = "none")]
        .           impl<'a> Arguments<'a> {
        .               #[inline]
1,988,482 ( 1.68%)      pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {
        .                   const { assert!(N <= 1) };
       45 ( 0.00%)          Arguments { pieces, fmt: None, args: &[] }
        5 ( 0.00%)      }
        .           
        .               /// When using the format_args!() macro, this function is used to generate the
        .               /// Arguments structure.
        .               #[inline]
       42 ( 0.00%)      pub const fn new_v1<const P: usize, const A: usize>(
       26 ( 0.00%)          pieces: &'a [&'static str; P],
        .                   args: &'a [rt::Argument<'a>; A],
        .               ) -> Arguments<'a> {
        .                   const { assert!(P >= A && P <= A + 1, "invalid args") }
      112 ( 0.00%)          Arguments { pieces, fmt: None, args }
       14 ( 0.00%)      }
        .           
        .               /// Specifies nonstandard formatting parameters.
        .               ///
        .               /// An `rt::UnsafeArg` is required because the following invariants must be held
        .               /// in order for this function to be safe:
        .               /// 1. The `pieces` slice must be at least as long as `fmt`.
        .               /// 2. Every `rt::Placeholder::position` value within `fmt` must be a valid index of `args`.
        .               /// 3. Every `rt::Count::Param` within `fmt` must contain a valid index of `args`.
        .               #[inline]
       27 ( 0.00%)      pub const fn new_v1_formatted(
        .                   pieces: &'a [&'static str],
        .                   args: &'a [rt::Argument<'a>],
        .                   fmt: &'a [rt::Placeholder],
        .                   _unsafe_arg: rt::UnsafeArg,
        .               ) -> Arguments<'a> {
       30 ( 0.00%)          Arguments { pieces, fmt: Some(fmt), args }
        3 ( 0.00%)      }
        .           
        .               /// Estimates the length of the formatted text.
        .               ///
        .               /// This is intended to be used for setting initial `String` capacity
        .               /// when using `format!`. Note: this is neither the lower nor upper bound.
        .               #[inline]
        .               pub fn estimated_capacity(&self) -> usize {
        .                   let pieces_length: usize = self.pieces.iter().map(|x| x.len()).sum();
-- line 639 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/alignment.rs
--------------------------------------------------------------------------------
Ir              

-- line 84 ----------------------------------------
     .                   // our variants encompass all possible powers of two.
     .                   unsafe { mem::transmute::<usize, Alignment>(align) }
     .               }
     .           
     .               /// Returns the alignment as a [`usize`].
     .               #[unstable(feature = "ptr_alignment_type", issue = "102070")]
     .               #[inline]
     .               pub const fn as_usize(self) -> usize {
64,102 ( 0.05%)          self.0 as usize
     .               }
     .           
     .               /// Returns the alignment as a <code>[NonZero]<[usize]></code>.
     .               #[unstable(feature = "ptr_alignment_type", issue = "102070")]
     .               #[inline]
     .               pub const fn as_nonzero(self) -> NonZero<usize> {
     .                   // This transmutes directly to avoid the UbCheck in `NonZero::new_unchecked`
     .                   // since there's no way for the user to trip that check anyway -- the
-- line 100 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs
--------------------------------------------------------------------------------
Ir                 

-- line 370 ----------------------------------------
        .               ///
        .               /// assert_eq!(3..=5, RangeInclusive::new(3, 5));
        .               /// ```
        .               #[lang = "range_inclusive_new"]
        .               #[stable(feature = "inclusive_range_methods", since = "1.27.0")]
        .               #[inline]
        .               #[rustc_promotable]
        .               #[rustc_const_stable(feature = "const_range_new", since = "1.32.0")]
  192,024 ( 0.16%)      pub const fn new(start: Idx, end: Idx) -> Self {
  192,024 ( 0.16%)          Self { start, end, exhausted: false }
   64,008 ( 0.05%)      }
        .           
        .               /// Returns the lower bound of the range (inclusive).
        .               ///
        .               /// When using an inclusive range for iteration, the values of `start()` and
        .               /// [`end()`] are unspecified after the iteration ended. To determine
        .               /// whether the inclusive range is empty, use the [`is_empty()`] method
        .               /// instead of comparing `start() > end()`.
        .               ///
-- line 388 ----------------------------------------
-- line 538 ----------------------------------------
        .               /// let mut r = 3..=5;
        .               /// for _ in r.by_ref() {}
        .               /// // Precise field values are unspecified here
        .               /// assert!(r.is_empty());
        .               /// ```
        .               #[stable(feature = "range_is_empty", since = "1.47.0")]
        .               #[inline]
        .               pub fn is_empty(&self) -> bool {
1,024,016 ( 0.87%)          self.exhausted || !(self.start <= self.end)
        .               }
        .           }
        .           
        .           /// A range only bounded inclusively above (`..=end`).
        .           ///
        .           /// The `RangeToInclusive` `..=end` contains all values with `x <= end`.
        .           /// It cannot serve as an [`Iterator`] because it doesn't have a starting point.
        .           ///
-- line 554 ----------------------------------------

  128,000 ( 0.11%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs
--------------------------------------------------------------------------------
Ir              

-- line 737 ----------------------------------------
     .               /// // Instead, use for:
     .               /// for x in 0..5 {
     .               ///     println!("{x}");
     .               /// }
     .               /// ```
     .               #[rustc_diagnostic_item = "IteratorMap"]
     .               #[inline]
     .               #[stable(feature = "rust1", since = "1.0.0")]
 1,288 ( 0.00%)      fn map<B, F>(self, f: F) -> Map<Self, F>
     .               where
     .                   Self: Sized,
     .                   F: FnMut(Self::Item) -> B,
     .               {
     .                   Map::new(self, f)
   322 ( 0.00%)      }
     .           
     .               /// Calls a closure on each element of an iterator.
     .               ///
     .               /// This is equivalent to using a [`for`] loop on the iterator, although
     .               /// `break` and `continue` are not possible from a closure. It's generally
     .               /// more idiomatic to use a `for` loop, but `for_each` may be more legible
     .               /// when processing items at the end of longer iterator chains. In some
     .               /// cases `for_each` may also be faster than a loop, because it will use
-- line 759 ----------------------------------------
-- line 782 ----------------------------------------
     .               /// ```
     .               /// (0..5).flat_map(|x| x * 100 .. x * 110)
     .               ///       .enumerate()
     .               ///       .filter(|&(i, x)| (i + x) % 3 == 0)
     .               ///       .for_each(|(i, x)| println!("{i}:{x}"));
     .               /// ```
     .               #[inline]
     .               #[stable(feature = "iterator_for_each", since = "1.21.0")]
     3 ( 0.00%)      fn for_each<F>(self, f: F)
     .               where
     .                   Self: Sized,
     .                   F: FnMut(Self::Item),
     .               {
     .                   #[inline]
     .                   fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {
13,318 ( 0.01%)              move |(), item| f(item)
12,288 ( 0.01%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::extend_trusted::{{closure}} (1,024x)
     .                   }
     .           
     2 ( 0.00%)          self.fold((), call(f));
139,345 ( 0.12%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold (1x)
     2 ( 0.00%)      }
     .           
     .               /// Creates an iterator which uses a closure to determine if an element
     .               /// should be yielded.
     .               ///
     .               /// Given an element the closure must return `true` or `false`. The returned
     .               /// iterator will yield only the elements for which the closure returns
     .               /// `true`.
     .               ///
-- line 809 ----------------------------------------
-- line 950 ----------------------------------------
     .               /// assert_eq!(iter.next(), Some((0, &'a')));
     .               /// assert_eq!(iter.next(), Some((1, &'b')));
     .               /// assert_eq!(iter.next(), Some((2, &'c')));
     .               /// assert_eq!(iter.next(), None);
     .               /// ```
     .               #[inline]
     .               #[stable(feature = "rust1", since = "1.0.0")]
     .               #[cfg_attr(not(test), rustc_diagnostic_item = "enumerate_method")]
32,003 ( 0.03%)      fn enumerate(self) -> Enumerate<Self>
     .               where
     .                   Self: Sized,
     .               {
     .                   Enumerate::new(self)
32,001 ( 0.03%)      }
     .           
     .               /// Creates an iterator which can use the [`peek`] and [`peek_mut`] methods
     .               /// to look at the next element of the iterator without consuming it. See
     .               /// their documentation for more information.
     .               ///
     .               /// Note that the underlying iterator is still advanced when [`peek`] or
     .               /// [`peek_mut`] are called for the first time: In order to retrieve the
     .               /// next element, [`next`] is called on the underlying iterator, hence any
-- line 971 ----------------------------------------
-- line 1959 ----------------------------------------
     .               ///
     .               /// [`iter`]: Iterator::next
     .               /// [`String`]: ../../std/string/struct.String.html
     .               /// [`char`]: type@char
     .               #[inline]
     .               #[stable(feature = "rust1", since = "1.0.0")]
     .               #[must_use = "if you really need to exhaust the iterator, consider `.for_each(drop)` instead"]
     .               #[cfg_attr(not(test), rustc_diagnostic_item = "iterator_collect_fn")]
     5 ( 0.00%)      fn collect<B: FromIterator<Self::Item>>(self) -> B
     .               where
     .                   Self: Sized,
     .               {
     3 ( 0.00%)          FromIterator::from_iter(self)
139,920 ( 0.12%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter (1x)
     2 ( 0.00%)      }
     .           
     .               /// Fallibly transforms an iterator into a collection, short circuiting if
     .               /// a failure is encountered.
     .               ///
     .               /// `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible
     .               /// conversions during collection. Its main use case is simplifying conversions from
     .               /// iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]
     .               /// types (e.g. [`Result`]).
-- line 1980 ----------------------------------------
-- line 2531 ----------------------------------------
     .               /// // they're the same
     .               /// assert_eq!(result, result2);
     .               /// ```
     .               ///
     .               /// [`reduce()`]: Iterator::reduce
     .               #[doc(alias = "inject", alias = "foldl")]
     .               #[inline]
     .               #[stable(feature = "rust1", since = "1.0.0")]
     4 ( 0.00%)      fn fold<B, F>(mut self, init: B, mut f: F) -> B
     .               where
     .                   Self: Sized,
     .                   F: FnMut(B, Self::Item) -> B,
     .               {
     1 ( 0.00%)          let mut accum = init;
11,272 ( 0.01%)          while let Some(x) = self.next() {
53,269 ( 0.05%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next (1,025x)
 4,096 ( 0.00%)              accum = f(accum, x);
66,560 ( 0.06%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:core::iter::adapters::map::map_fold::{{closure}} (1,024x)
     1 ( 0.00%)          }
     .                   accum
     4 ( 0.00%)      }
    25 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<core::iter::adapters::map::map_fold<usize,core::sync::atomic::AtomicI64,(),oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>::new::{{closure}},core::iter::traits::iterator::Iterator::for_each::call<core::sync::atomic::AtomicI64,alloc::vec::Vec<core::sync::atomic::AtomicI64>::extend_trusted<core::iter::adapters::map::Map<core::ops::range::Range<usize>,oxidator::coordinator::sequencer::MultiProducerSequencer<oxidator::coordinator::wait::YieldingWaitStrategy>::new::{{closure}}>>::{{closure}}>::{{closure}}>::{{closure}}> (1x)
     .           
     .               /// Reduces the elements to a single one, by repeatedly applying a reducing
     .               /// operation.
     .               ///
     .               /// If the iterator is empty, returns [`None`]; otherwise, returns the
     .               /// result of the reduction.
     .               ///
     .               /// The reducing function is a closure with two arguments: an 'accumulator', and an element.
-- line 2557 ----------------------------------------
-- line 2568 ----------------------------------------
     .               /// assert_eq!(reduced, 45);
     .               ///
     .               /// // Which is equivalent to doing it with `fold`:
     .               /// let folded: i32 = (1..10).fold(0, |acc, e| acc + e);
     .               /// assert_eq!(reduced, folded);
     .               /// ```
     .               #[inline]
     .               #[stable(feature = "iterator_fold_self", since = "1.51.0")]
   963 ( 0.00%)      fn reduce<F>(mut self, f: F) -> Option<Self::Item>
     .               where
     .                   Self: Sized,
     .                   F: FnMut(Self::Item, Self::Item) -> Self::Item,
     .               {
 3,531 ( 0.00%)          let first = self.next()?;
39,483 ( 0.03%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::next (321x)
 2,889 ( 0.00%)          Some(self.fold(first, f))
76,211 ( 0.06%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/map.rs:<core::iter::adapters::map::Map<I,F> as core::iter::traits::iterator::Iterator>::fold (321x)
 1,605 ( 0.00%)      }
     .           
     .               /// Reduces the elements to a single one by repeatedly applying a reducing operation. If the
     .               /// closure returns a failure, the failure is propagated back to the caller immediately.
     .               ///
     .               /// The return type of this method depends on the return type of the closure. If the closure
     .               /// returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>,
     .               /// E>`. If the closure returns `Option<Self::Item>`, then this function will return
     .               /// `Option<Option<Self::Item>>`.
-- line 2591 ----------------------------------------
-- line 3135 ----------------------------------------
     .               /// let a = [1, 2, 3];
     .               /// let b: Vec<u32> = Vec::new();
     .               ///
     .               /// assert_eq!(a.iter().min(), Some(&1));
     .               /// assert_eq!(b.iter().min(), None);
     .               /// ```
     .               #[inline]
     .               #[stable(feature = "rust1", since = "1.0.0")]
   963 ( 0.00%)      fn min(self) -> Option<Self::Item>
     .               where
     .                   Self: Sized,
     .                   Self::Item: Ord,
     .               {
   321 ( 0.00%)          self.min_by(Ord::cmp)
129,497 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:core::iter::traits::iterator::Iterator::min_by (321x)
   642 ( 0.00%)      }
     .           
     .               /// Returns the element that gives the maximum value from the
     .               /// specified function.
     .               ///
     .               /// If several elements are equally maximum, the last element is
     .               /// returned. If the iterator is empty, [`None`] is returned.
     .               ///
     .               /// # Examples
-- line 3157 ----------------------------------------
-- line 3250 ----------------------------------------
     .               /// # Examples
     .               ///
     .               /// ```
     .               /// let a = [-3_i32, 0, 1, 5, -10];
     .               /// assert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);
     .               /// ```
     .               #[inline]
     .               #[stable(feature = "iter_min_by", since = "1.15.0")]
   963 ( 0.00%)      fn min_by<F>(self, compare: F) -> Option<Self::Item>
     .               where
     .                   Self: Sized,
     .                   F: FnMut(&Self::Item, &Self::Item) -> Ordering,
     .               {
     .                   #[inline]
     .                   fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {
 3,913 ( 0.00%)              move |x, y| cmp::min_by(x, y, &mut compare)
15,953 ( 0.01%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:core::cmp::min_by (301x)
     .                   }
     .           
   321 ( 0.00%)          self.reduce(fold(compare))
127,571 ( 0.11%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:core::iter::traits::iterator::Iterator::reduce (321x)
   642 ( 0.00%)      }
     .           
     .               /// Reverses an iterator's direction.
     .               ///
     .               /// Usually, iterators iterate from left to right. After using `rev()`,
     .               /// an iterator will instead iterate from right to left.
     .               ///
     .               /// This is only possible if the iterator has an end, so `rev()` only
     .               /// works on [`DoubleEndedIterator`]s.
-- line 3277 ----------------------------------------

 5,063 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs
--------------------------------------------------------------------------------
Ir                 

-- line 58 ----------------------------------------
        .                       // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and
        .                       // would be bad for compile times.
        .                       //
        .                       // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without
        .                       // inlining the check. If it's `true`, it can inline it and get significantly better performance.
        .                       #[rustc_no_mir_inline]
        .                       #[inline]
        .                       #[rustc_nounwind]
3,305,053 ( 2.80%)              const fn precondition_check($($name:$ty),*) {
        .                           if !$e {
        .                               ::core::panicking::panic_nounwind(
        .                                   concat!("unsafe precondition(s) violated: ", $message)
        .                               );
        .                           }
1,093,724 ( 0.93%)              }
        .           
   32,052 ( 0.03%)              if ::core::ub_checks::$kind() {
1,027,377 ( 0.87%)                  precondition_check($($arg,)*);
  672,000 ( 0.57%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked::precondition_check (96,000x)
        .                       }
        .                   }
        .               };
        .           }
        .           #[unstable(feature = "ub_checks", issue = "none")]
        .           pub use assert_unsafe_precondition;
        .           /// Checking library UB is always enabled when UB-checking is done
        .           /// (and we use a reexport so that there is no unnecessary wrapper function).
-- line 83 ----------------------------------------
-- line 111 ----------------------------------------
        .           /// In `const` this is approximate and can fail spuriously. It is primarily intended
        .           /// for `assert_unsafe_precondition!` with `check_language_ub`, in which case the
        .           /// check is anyway not executed in `const`.
        .           #[inline]
        .           #[rustc_allow_const_fn_unstable(const_eval_select)]
        .           pub(crate) const fn maybe_is_aligned_and_not_null(
        .               ptr: *const (),
        .               align: usize,
  192,030 ( 0.16%)      is_zst: bool,
        .           ) -> bool {
        .               // This is just for safety checks so we can const_eval_select.
        .               const_eval_select!(
        .                   @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:
        .                   if const {
        .                       is_zst || !ptr.is_null()
        .                   } else {
  768,380 ( 0.65%)              ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())
        .                   }
        .               )
        .           }
        .           
        .           #[inline]
        .           pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {
2,496,390 ( 2.11%)      let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };
  192,030 ( 0.16%)      len <= max_len
        .           }
        .           
        .           /// Checks whether the regions of memory starting at `src` and `dst` of size
        .           /// `count * size` do *not* overlap.
        .           ///
        .           /// Note that in const-eval this function just returns `true` and therefore must
        .           /// only be used with `assert_unsafe_precondition!`, similar to `is_aligned_and_not_null`.
        .           #[inline]
-- line 143 ----------------------------------------
-- line 151 ----------------------------------------
        .               // This is just for safety checks so we can const_eval_select.
        .               const_eval_select!(
        .                   @capture { src: *const (), dst: *const (), size: usize, count: usize } -> bool:
        .                   if const {
        .                       true
        .                   } else {
        .                       let src_usize = src.addr();
        .                       let dst_usize = dst.addr();
       30 ( 0.00%)              let Some(size) = size.checked_mul(count) else {
        .                           crate::panicking::panic_nounwind(
        .                               "is_nonoverlapping: `size_of::<T>() * count` overflows a usize",
        .                           )
        .                       };
        .                       let diff = src_usize.abs_diff(dst_usize);
        .                       // If the absolute distance between the ptrs is at least as big as the size of the buffer,
        .                       // they do not overlap.
       20 ( 0.00%)              diff >= size
        .                   }
        .               )
        .           }

1,668,982 ( 1.41%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs
--------------------------------------------------------------------------------
Ir               

-- line 515 ----------------------------------------
      .           ///
      .           /// // Ensure that the last item was dropped.
      .           /// assert!(weak.upgrade().is_none());
      .           /// ```
      .           #[stable(feature = "drop_in_place", since = "1.8.0")]
      .           #[lang = "drop_in_place"]
      .           #[allow(unconditional_recursion)]
      .           #[rustc_diagnostic_item = "ptr_drop_in_place"]
802,025 ( 0.68%)  pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
      5 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/set_len_on_drop.rs:<alloc::vec::set_len_on_drop::SetLenOnDrop as core::ops::drop::Drop>::drop (1x)
      .               // Code here does not matter - this is replaced by the
      .               // real drop glue by the compiler.
      .           
      .               // SAFETY: see comment above
      .               unsafe { drop_in_place(to_drop) }
      .           }
      .           
      .           /// Creates a null raw pointer.
-- line 531 ----------------------------------------
-- line 591 ----------------------------------------
      .           /// exposed provenance. See [`with_exposed_provenance`] for more details on that operation.
      .           ///
      .           /// This is a [Strict Provenance][crate::ptr#strict-provenance] API.
      .           #[inline(always)]
      .           #[must_use]
      .           #[stable(feature = "strict_provenance", since = "1.84.0")]
      .           #[rustc_const_stable(feature = "strict_provenance", since = "1.84.0")]
      .           pub const fn without_provenance<T>(addr: usize) -> *const T {
      4 ( 0.00%)      without_provenance_mut(addr)
      .           }
      .           
      .           /// Creates a new pointer that is dangling, but non-null and well-aligned.
      .           ///
      .           /// This is useful for initializing types which lazily allocate, like
      .           /// `Vec::new` does.
      .           ///
      .           /// Note that the pointer value may potentially represent a valid pointer to
-- line 607 ----------------------------------------
-- line 922 ----------------------------------------
      .           /// unsafe {
      .           ///     danger.as_mut().expect("references must not be null");
      .           /// }
      .           /// ```
      .           #[inline]
      .           #[stable(feature = "slice_from_raw_parts", since = "1.42.0")]
      .           #[rustc_const_stable(feature = "const_slice_from_raw_parts_mut", since = "1.83.0")]
      .           #[rustc_diagnostic_item = "ptr_slice_from_raw_parts_mut"]
 32,031 ( 0.03%)  pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {
      .               from_raw_parts_mut(data, len)
      .           }
      .           
      .           /// Swaps the values at two mutable locations of the same type, without
      .           /// deinitializing either.
      .           ///
      .           /// But for the following exceptions, this function is semantically
      .           /// equivalent to [`mem::swap`]:
-- line 938 ----------------------------------------
-- line 1217 ----------------------------------------
      .               unsafe {
      .                   ub_checks::assert_unsafe_precondition!(
      .                       check_language_ub,
      .                       "ptr::replace requires that the pointer argument is aligned and non-null",
      .                       (
      .                           addr: *const () = dst as *const (),
      .                           align: usize = align_of::<T>(),
      .                           is_zst: bool = T::IS_ZST,
      2 ( 0.00%)              ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
      .                   );
      .                   mem::replace(&mut *dst, src)
      .               }
      .           }
      .           
      .           /// Reads the value from `src` without moving it. This leaves the
      .           /// memory in `src` unchanged.
      .           ///
-- line 1233 ----------------------------------------
-- line 1372 ----------------------------------------
      .                       check_language_ub,
      .                       "ptr::read requires that the pointer argument is aligned and non-null",
      .                       (
      .                           addr: *const () = src as *const (),
      .                           align: usize = align_of::<T>(),
      .                           is_zst: bool = T::IS_ZST,
      .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
      .                   );
192,154 ( 0.16%)          crate::intrinsics::read_via_copy(src)
     72 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (6x)
      .               }
      .           }
      .           
      .           /// Reads the value from `src` without moving it. This leaves the
      .           /// memory in `src` unchanged.
      .           ///
      .           /// Unlike [`read`], `read_unaligned` works with unaligned pointers.
      .           ///
-- line 1388 ----------------------------------------
-- line 1574 ----------------------------------------
      .                       check_language_ub,
      .                       "ptr::write requires that the pointer argument is aligned and non-null",
      .                       (
      .                           addr: *mut () = dst as *mut (),
      .                           align: usize = align_of::<T>(),
      .                           is_zst: bool = T::IS_ZST,
      .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
      .                   );
 68,223 ( 0.06%)          intrinsics::write_via_move(dst, src)
      .               }
      .           }
      .           
      .           /// Overwrites a memory location with the given value without reading or
      .           /// dropping the old value.
      .           ///
      .           /// Unlike [`write()`], the pointer may be unaligned.
      .           ///
-- line 1590 ----------------------------------------
-- line 1732 ----------------------------------------
      .           /// unsafe {
      .           ///     assert_eq!(std::ptr::read_volatile(y), 12);
      .           /// }
      .           /// ```
      .           #[inline]
      .           #[stable(feature = "volatile", since = "1.9.0")]
      .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .           #[rustc_diagnostic_item = "ptr_read_volatile"]
 64,058 ( 0.05%)  pub unsafe fn read_volatile<T>(src: *const T) -> T {
      .               // SAFETY: the caller must uphold the safety contract for `volatile_load`.
      .               unsafe {
      .                   ub_checks::assert_unsafe_precondition!(
      .                       check_language_ub,
      .                       "ptr::read_volatile requires that the pointer argument is aligned and non-null",
      .                       (
      .                           addr: *const () = src as *const (),
      .                           align: usize = align_of::<T>(),
      .                           is_zst: bool = T::IS_ZST,
 64,058 ( 0.05%)              ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)
      .                   );
 96,087 ( 0.08%)          intrinsics::volatile_load(src)
      .               }
      .           }
      .           
      .           /// Performs a volatile write of a memory location with the given value without
      .           /// reading or dropping the old value.
      .           ///
      .           /// Volatile operations are intended to act on I/O memory, and are guaranteed
      .           /// to not be elided or reordered by the compiler across other volatile
-- line 1760 ----------------------------------------

 32,148 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs
--------------------------------------------------------------------------------
Ir               

-- line 126 ----------------------------------------
      .               ///
      .               /// let b: &[i32] = &[];
      .               /// assert!(b.is_empty());
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_slice_is_empty", since = "1.39.0")]
      .               #[inline]
      .               #[must_use]
     20 ( 0.00%)      pub const fn is_empty(&self) -> bool {
     20 ( 0.00%)          self.len() == 0
     20 ( 0.00%)      }
      .           
      .               /// Returns the first element of the slice, or `None` if it is empty.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// let v = [10, 40, 30];
      .               /// assert_eq!(Some(&10), v.first());
-- line 144 ----------------------------------------
-- line 648 ----------------------------------------
      .               ///
      .               /// unsafe {
      .               ///     assert_eq!(x.get_unchecked(1), &2);
      .               /// }
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[inline]
      .               #[must_use]
768,000 ( 0.65%)      pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output
      .               where
      .                   I: SliceIndex<Self>,
      .               {
      .                   // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;
      .                   // the slice is dereferenceable because `self` is a safe reference.
      .                   // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.
 96,000 ( 0.08%)          unsafe { &*index.get_unchecked(self) }
2,208,000 ( 1.87%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:<usize as core::slice::index::SliceIndex<[T]>>::get_unchecked (96,000x)
192,000 ( 0.16%)      }
      .           
      .               /// Returns a mutable reference to an element or subslice, without doing
      .               /// bounds checking.
      .               ///
      .               /// For a safe alternative see [`get_mut`].
      .               ///
      .               /// # Safety
      .               ///
-- line 672 ----------------------------------------
-- line 733 ----------------------------------------
      .               /// [`as_mut_ptr`]: slice::as_mut_ptr
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_slice_as_ptr", since = "1.32.0")]
      .               #[rustc_never_returns_null_ptr]
      .               #[rustc_as_ptr]
      .               #[inline(always)]
      .               #[must_use]
      .               pub const fn as_ptr(&self) -> *const T {
      5 ( 0.00%)          self as *const [T] as *const T
      .               }
      .           
      .               /// Returns an unsafe mutable pointer to the slice's buffer.
      .               ///
      .               /// The caller must ensure that the slice outlives the pointer this
      .               /// function returns, or else it will end up dangling.
      .               ///
      .               /// Modifying the container referenced by this slice may cause its buffer
-- line 749 ----------------------------------------
-- line 764 ----------------------------------------
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_ptr_offset", since = "1.61.0")]
      .               #[rustc_never_returns_null_ptr]
      .               #[rustc_as_ptr]
      .               #[inline(always)]
      .               #[must_use]
      .               pub const fn as_mut_ptr(&mut self) -> *mut T {
      1 ( 0.00%)          self as *mut [T] as *mut T
      .               }
      .           
      .               /// Returns the two raw pointers spanning the slice.
      .               ///
      .               /// The returned range is half-open, which means that the end pointer
      .               /// points *one past* the last element of the slice. This way, an empty
      .               /// slice is represented by two equal pointers, and the difference between
      .               /// the two pointers represents the size of the slice.
-- line 780 ----------------------------------------
-- line 1042 ----------------------------------------
      .               /// assert_eq!(iterator.next(), Some(&1));
      .               /// assert_eq!(iterator.next(), Some(&2));
      .               /// assert_eq!(iterator.next(), Some(&4));
      .               /// assert_eq!(iterator.next(), None);
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[inline]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "slice_iter")]
    966 ( 0.00%)      pub fn iter(&self) -> Iter<'_, T> {
    322 ( 0.00%)          Iter::new(self)
  5,474 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter.rs:core::slice::iter::Iter<T>::new (322x)
    644 ( 0.00%)      }
      .           
      .               /// Returns an iterator that allows modifying each value.
      .               ///
      .               /// The iterator yields all items from start to end.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
-- line 1060 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs
--------------------------------------------------------------------------------
Ir               

-- line 108 ----------------------------------------
      .               /// let mut range = 0..5;
      .               ///
      .               /// assert_eq!(5, range.len());
      .               /// let _ = range.next();
      .               /// assert_eq!(4, range.len());
      .               /// ```
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
192,012 ( 0.16%)      fn len(&self) -> usize {
576,036 ( 0.49%)          let (lower, upper) = self.size_hint();
3,264,210 ( 2.76%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:<alloc::vec::into_iter::IntoIter<T,A> as core::iter::traits::iterator::Iterator>::size_hint (64,004x)
      .                   // Note: This assertion is overly defensive, but it checks the invariant
      .                   // guaranteed by the trait. If this trait were rust-internal,
      .                   // we could use debug_assert!; assert_eq! will check all Rust user
      .                   // implementations too.
128,008 ( 0.11%)          assert_eq!(upper, Some(lower));
      .                   lower
128,008 ( 0.11%)      }
      .           
      .               /// Returns `true` if the iterator is empty.
      .               ///
      .               /// This method has a default implementation using
      .               /// [`ExactSizeIterator::len()`], so you don't need to implement it yourself.
      .               ///
      .               /// # Examples
      .               ///
-- line 132 ----------------------------------------
-- line 148 ----------------------------------------
      .               fn is_empty(&self) -> bool {
      .                   self.len() == 0
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for &mut I {
      .               fn len(&self) -> usize {
128,020 ( 0.11%)          (**self).len()
2,944,374 ( 2.49%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/exact_size.rs:core::iter::traits::exact_size::ExactSizeIterator::len (32,004x)
      .               }
      .               fn is_empty(&self) -> bool {
      .                   (**self).is_empty()
      .               }
      .           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs
--------------------------------------------------------------------------------
Ir               

-- line 91 ----------------------------------------
      .           
      .               use crate::boxed::Box;
      .               use crate::vec::Vec;
      .           
      .               // We shouldn't add inline attribute to this since this is used in
      .               // `vec!` macro mostly and causes perf regression. See #71204 for
      .               // discussion and perf results.
      .               #[allow(missing_docs)]
224,007 ( 0.19%)      pub fn into_vec<T, A: Allocator>(b: Box<[T], A>) -> Vec<T, A> {
      .                   unsafe {
 32,001 ( 0.03%)              let len = b.len();
      .                       let (b, alloc) = Box::into_raw_with_allocator(b);
 32,001 ( 0.03%)              Vec::from_raw_parts_in(b as *mut T, len, len, alloc)
      .                   }
 64,002 ( 0.05%)      }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               #[allow(missing_docs)]
      .               #[inline]
      .               pub fn to_vec<T: ConvertVec, A: Allocator>(s: &[T], alloc: A) -> Vec<T, A> {
      2 ( 0.00%)          T::to_vec(s, alloc)
    282 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:<T as alloc::slice::hack::ConvertVec>::to_vec (1x)
      .               }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               pub trait ConvertVec {
      .                   fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>
      .                   where
      .                       Self: Sized;
      .               }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               impl<T: Clone> ConvertVec for T {
      .                   #[inline]
      9 ( 0.00%)          default fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {
      .                       struct DropGuard<'a, T, A: Allocator> {
      .                           vec: &'a mut Vec<T, A>,
      .                           num_init: usize,
      .                       }
      .                       impl<'a, T, A: Allocator> Drop for DropGuard<'a, T, A> {
      .                           #[inline]
      .                           fn drop(&mut self) {
      .                               // SAFETY:
      .                               // items were marked initialized in the loop below
      .                               unsafe {
      .                                   self.vec.set_len(self.num_init);
      .                               }
      .                           }
      .                       }
      1 ( 0.00%)              let mut vec = Vec::with_capacity_in(s.len(), alloc);
      3 ( 0.00%)              let mut guard = DropGuard { vec: &mut vec, num_init: 0 };
      3 ( 0.00%)              let slots = guard.vec.spare_capacity_mut();
      .                       // .take(slots.len()) is necessary for LLVM to remove bounds checks
      .                       // and has better codegen than zip.
     11 ( 0.00%)              for (i, b) in s.iter().enumerate().take(slots.len()) {
      .                           guard.num_init = i;
      .                           slots[i].write(b.clone());
      .                       }
      4 ( 0.00%)              core::mem::forget(guard);
      .                       // SAFETY:
      .                       // the vec was allocated and initialized above to at least this length.
      .                       unsafe {
      2 ( 0.00%)                  vec.set_len(s.len());
      .                       }
      6 ( 0.00%)              vec
      2 ( 0.00%)          }
      .               }
      .           
      .               #[cfg(not(no_global_oom_handling))]
      .               impl<T: Copy> ConvertVec for T {
      .                   #[inline]
      .                   fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {
      .                       let mut v = Vec::with_capacity_in(s.len(), alloc);
      .                       // SAFETY:
-- line 163 ----------------------------------------
-- line 518 ----------------------------------------
      .               /// // `s` cannot be used anymore because it has been converted into `x`.
      .               ///
      .               /// assert_eq!(x, vec![10, 40, 30]);
      .               /// ```
      .               #[rustc_allow_incoherent_impl]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[inline]
      .               #[cfg_attr(not(test), rustc_diagnostic_item = "slice_into_vec")]
160,005 ( 0.14%)      pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {
      .                   // N.B., see the `hack` module in this file for more details.
 64,002 ( 0.05%)          hack::into_vec(self)
1,120,035 ( 0.95%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:alloc::slice::hack::into_vec (32,001x)
 64,002 ( 0.05%)      }
      .           
      .               /// Creates a vector by copying a slice `n` times.
      .               ///
      .               /// # Panics
      .               ///
      .               /// This function will panic if the capacity would overflow.
      .               ///
      .               /// # Examples
-- line 537 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/raw.rs
--------------------------------------------------------------------------------
Ir               

-- line 127 ----------------------------------------
      .                       check_language_ub,
      .                       "slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`",
      .                       (
      .                           data: *mut () = data as *mut (),
      .                           size: usize = size_of::<T>(),
      .                           align: usize = align_of::<T>(),
      .                           len: usize = len,
      .                       ) =>
576,078 ( 0.49%)              ub_checks::maybe_is_aligned_and_not_null(data, align, false)
192,026 ( 0.16%)                  && ub_checks::is_valid_allocation_size(size, len)
      .                   );
      .                   &*ptr::slice_from_raw_parts(data, len)
      .               }
      .           }
      .           
      .           /// Performs the same functionality as [`from_raw_parts`], except that a
      .           /// mutable slice is returned.
      .           ///
-- line 144 ----------------------------------------
-- line 181 ----------------------------------------
      .                       check_language_ub,
      .                       "slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`",
      .                       (
      .                           data: *mut () = data as *mut (),
      .                           size: usize = size_of::<T>(),
      .                           align: usize = align_of::<T>(),
      .                           len: usize = len,
      .                       ) =>
     12 ( 0.00%)              ub_checks::maybe_is_aligned_and_not_null(data, align, false)
      4 ( 0.00%)                  && ub_checks::is_valid_allocation_size(size, len)
      .                   );
      8 ( 0.00%)          &mut *ptr::slice_from_raw_parts_mut(data, len)
      .               }
      .           }
      .           
      .           /// Converts a reference to T into a slice of length 1 (without copying).
      .           #[stable(feature = "from_ref", since = "1.28.0")]
      .           #[rustc_const_stable(feature = "const_slice_from_ref_shared", since = "1.63.0")]
      .           #[must_use]
      .           pub const fn from_ref<T>(s: &T) -> &[T] {
-- line 200 ----------------------------------------

192,030 ( 0.16%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/raw.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/traits/traits.rs
--------------------------------------------------------------------------------
Ir               

-- line 31 ----------------------------------------
      .           pub const CACHE_LINE_PADDING: usize = CACHE_LINE_SIZE - size_of::<AtomicI64>();
      .           
      .           pub struct AtomicSequence {
      .               value: AtomicI64,
      .               _padding: [u8; CACHE_LINE_PADDING]
      .           }
      .           
      .           impl AtomicSequence {
193,250 ( 0.16%)      pub fn load(&self) -> Sequence {
289,875 ( 0.25%)          self.value.load(Ordering::Acquire)
3,092,000 ( 2.62%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::load (96,625x)
193,250 ( 0.16%)      }
      .           
     24 ( 0.00%)      pub fn store(&self, s: Sequence) {
     24 ( 0.00%)          self.value.store(s, Ordering::Release)
    272 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::store (8x)
     16 ( 0.00%)      }
      .           
256,000 ( 0.22%)      pub fn compare_exchange(&self, old: Sequence, new: Sequence) -> bool {
640,000 ( 0.54%)          self.value.compare_exchange(old, new, Ordering::SeqCst, Ordering::Relaxed).is_ok()
4,160,000 ( 3.52%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::compare_exchange (64,000x)
320,000 ( 0.27%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:core::result::Result<T,E>::is_ok (64,000x)
192,000 ( 0.16%)      }
      .           }
      .           
      .           impl From<Sequence> for AtomicSequence {
     35 ( 0.00%)      fn from(value: Sequence) -> Self {
     40 ( 0.00%)          Self {
     60 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (5x)
     20 ( 0.00%)              value: AtomicI64::new(value),
     20 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::AtomicI64::new (5x)
     30 ( 0.00%)              _padding: [0u8; CACHE_LINE_PADDING]
     60 ( 0.00%)  => ???:__memset_avx2_unaligned_erms (5x)
      .                   }
     10 ( 0.00%)      }
      .           }
      .           
      .           impl Default for AtomicSequence {
      6 ( 0.00%)      fn default() -> Self {
      6 ( 0.00%)          AtomicSequence::from(-1)
    110 ( 0.00%)  => src/traits/traits.rs:<oxidator::traits::traits::AtomicSequence as core::convert::From<i64>>::from (2x)
      4 ( 0.00%)      }
      .           }
      .           
      .           impl AsRef<AtomicSequence> for AtomicSequence {
      .               fn as_ref(&self) -> &AtomicSequence {
      .                   self
      .               }
      .           }
      .           
-- line 72 ----------------------------------------
-- line 151 ----------------------------------------
      .           
      .           impl<T> Clone for Box<dyn Task<T> + Send + Sync + 'static> {
      .               fn clone(&self) -> Self {
      .                   self.clone_box()
      .               }
      .           }
      .           
      .           impl<T> Task<T> for Box<dyn Task<T> + Send + Sync + 'static> {
512,000 ( 0.43%)      fn execute_task(&self, event: &T, sequence: Sequence, eob: bool) {
384,000 ( 0.32%)          (**self).execute_task(event, sequence, eob);
14,875,904 (12.59%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/samples/multi_producer_sample.rs:<multi_producer::SumTask as oxidator::traits::traits::Task<multi_producer::Event>>::execute_task (32,000x)
224,000 ( 0.19%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/samples/multi_producer_sample.rs:<multi_producer::PrinterTask as oxidator::traits::traits::Task<multi_producer::Event>>::execute_task (32,000x)
128,000 ( 0.11%)      }
      .           
      .               fn clone_box(&self) -> Box<dyn Task<T> + Send + Sync + 'static> {
      .                   (**self).clone_box()
      .               }
      .           }
      .           
      .           pub trait TaskMut<T> {
      .               fn execute_task(&self, event: &mut T, sequence: Sequence, eob: bool);
-- line 169 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs
--------------------------------------------------------------------------------
Ir               

-- line 18 ----------------------------------------
      .           use crate::collections::VecDeque;
      .           use crate::raw_vec::RawVec;
      .           
      .           macro non_null {
      .               (mut $place:expr, $t:ident) => {{
      .                   #![allow(unused_unsafe)] // we're sometimes used within an unsafe block
      .                   unsafe { &mut *((&raw mut $place) as *mut NonNull<$t>) }
      .               }},
128,024 ( 0.11%)      ($place:expr, $t:ident) => {{
      .                   #![allow(unused_unsafe)] // we're sometimes used within an unsafe block
192,028 ( 0.16%)          unsafe { *((&raw const $place) as *const NonNull<$t>) }
      .               }},
      .           }
      .           
      .           /// An iterator that moves out of a vector.
      .           ///
      .           /// This `struct` is created by the `into_iter` method on [`Vec`](super::Vec)
      .           /// (provided by the [`IntoIterator`] trait).
      .           ///
-- line 36 ----------------------------------------
-- line 105 ----------------------------------------
      .               /// Returns a reference to the underlying allocator.
      .               #[unstable(feature = "allocator_api", issue = "32838")]
      .               #[inline]
      .               pub fn allocator(&self) -> &A {
      .                   &self.alloc
      .               }
      .           
      .               fn as_raw_mut_slice(&mut self) -> *mut [T] {
 96,016 ( 0.08%)          ptr::slice_from_raw_parts_mut(self.ptr.as_ptr(), self.len())
      .               }
      .           
      .               /// Drops remaining elements and relinquishes the backing allocation.
      .               ///
      .               /// This method guarantees it won't panic before relinquishing the backing
      .               /// allocation.
      .               ///
      .               /// This is roughly equivalent to the following, but more efficient
-- line 121 ----------------------------------------
-- line 200 ----------------------------------------
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           unsafe impl<T: Sync, A: Allocator + Sync> Sync for IntoIter<T, A> {}
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T, A: Allocator> Iterator for IntoIter<T, A> {
      .               type Item = T;
      .           
      .               #[inline]
256,051 ( 0.22%)      fn next(&mut self) -> Option<T> {
 32,008 ( 0.03%)          let ptr = if T::IS_ZST {
      .                       if self.ptr.as_ptr() == self.end as *mut T {
      .                           return None;
      .                       }
      .                       // `ptr` has to stay where it is to remain aligned, so we reduce the length by 1 by
      .                       // reducing the `end`.
      .                       self.end = self.end.wrapping_byte_sub(1);
      .                       self.ptr
      .                   } else {
256,048 ( 0.22%)              if self.ptr == non_null!(self.end, T) {
 32,004 ( 0.03%)                  return None;
      .                       }
 64,016 ( 0.05%)              let old = self.ptr;
 32,008 ( 0.03%)              self.ptr = unsafe { old.add(1) };
 32,008 ( 0.03%)              old
      .                   };
160,056 ( 0.14%)          Some(unsafe { ptr.read() })
 96,031 ( 0.08%)      }
      .           
      .               #[inline]
384,024 ( 0.32%)      fn size_hint(&self) -> (usize, Option<usize>) {
      .                   let exact = if T::IS_ZST {
      .                       self.end.addr().wrapping_sub(self.ptr.as_ptr().addr())
      .                   } else {
192,012 ( 0.16%)              unsafe { non_null!(self.end, T).sub_ptr(self.ptr) }
1,792,118 ( 1.52%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:core::ptr::non_null::NonNull<T>::sub_ptr (64,004x)
      .                   };
576,036 ( 0.49%)          (exact, Some(exact))
128,008 ( 0.11%)      }
      .           
      .               #[inline]
      .               fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
      .                   let step_size = self.len().min(n);
      .                   let to_drop = ptr::slice_from_raw_parts_mut(self.ptr.as_ptr(), step_size);
      .                   if T::IS_ZST {
      .                       // See `next` for why we sub `end` here.
      .                       self.end = self.end.wrapping_byte_sub(step_size);
-- line 244 ----------------------------------------
-- line 479 ----------------------------------------
      .               #[cfg(test)]
      .               fn clone(&self) -> Self {
      .                   crate::slice::to_vec(self.as_slice(), self.alloc.deref().clone()).into_iter()
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {
 64,008 ( 0.05%)      fn drop(&mut self) {
      .                   struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);
      .           
      .                   impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {
 64,008 ( 0.05%)              fn drop(&mut self) {
      .                           unsafe {
      .                               // `IntoIter::alloc` is not used anymore after this and will be dropped by RawVec
 96,012 ( 0.08%)                      let alloc = ManuallyDrop::take(&mut self.0.alloc);
      .                               // RawVec handles deallocation
320,040 ( 0.27%)                      let _ = RawVec::from_nonnull_in(self.0.buf, self.0.cap, alloc);
4,224,000 ( 3.57%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::raw_vec::RawVec<multi_producer::Event>> (32,000x)
    275 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::raw_vec::RawVec<std::thread::JoinHandle<()>>> (3x)
    124 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<alloc::raw_vec::RawVec<alloc::boxed::Box<dyn oxidator::traits::traits::Worker>>> (1x)
      .                           }
 64,008 ( 0.05%)              }
      .                   }
      .           
 32,004 ( 0.03%)          let guard = DropGuard(self);
      .                   // destroy the remaining elements
      .                   unsafe {
 64,020 ( 0.05%)              ptr::drop_in_place(guard.0.as_raw_mut_slice());
     33 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[std::thread::JoinHandle<()>]> (3x)
     11 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<[alloc::boxed::Box<dyn oxidator::traits::traits::Worker>]> (1x)
      .                   }
      .                   // now `guard` will be dropped and do the rest
128,016 ( 0.11%)      }
5,184,000 ( 4.39%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<multi_producer::Event,alloc::alloc::Global>> (32,000x)
    365 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<std::thread::JoinHandle<()>,alloc::alloc::Global>> (3x)
    154 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:core::ptr::drop_in_place<<alloc::vec::into_iter::IntoIter<T,A> as core::ops::drop::Drop>::drop::DropGuard<alloc::boxed::Box<dyn oxidator::traits::traits::Worker>,alloc::alloc::Global>> (1x)
      .           }
      .           
      .           // In addition to the SAFETY invariants of the following three unsafe traits
      .           // also refer to the vec::in_place_collect module documentation to get an overview
      .           #[unstable(issue = "none", feature = "inplace_iteration")]
      .           #[doc(hidden)]
      .           unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {
      .               const EXPAND_BY: Option<NonZero<usize>> = NonZero::new(1);
-- line 515 ----------------------------------------

288,036 ( 0.24%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs
--------------------------------------------------------------------------------
Ir               

-- line 462 ----------------------------------------
      .               pub fn get_count() -> usize {
      .                   LOCAL_PANIC_COUNT.with(|c| c.get().0)
      .               }
      .           
      .               // Disregards ALWAYS_ABORT_FLAG
      .               #[must_use]
      .               #[inline]
      .               pub fn count_is_zero() -> bool {
416,039 ( 0.35%)          if GLOBAL_PANIC_COUNT.load(Ordering::Relaxed) & !ALWAYS_ABORT_FLAG == 0 {
      .                       // Fast path: if `GLOBAL_PANIC_COUNT` is zero, all threads
      .                       // (including the current one) will have `LOCAL_PANIC_COUNT`
      .                       // equal to zero, so TLS access can be avoided.
      .                       //
      .                       // In terms of performance, a relaxed atomic load is similar to a normal
      .                       // aligned memory read (e.g., a mov instruction in x86), but with some
      .                       // compiler optimization restrictions. On the other hand, a TLS access
      .                       // might require calling a non-inlinable function (such as `__tls_get_addr`
      .                       // when using the GD TLS model).
 32,003 ( 0.03%)              true
      .                   } else {
      .                       is_zero_slow_path()
      .                   }
      .               }
      .           
      .               // Slow path is in a separate function to reduce the amount of code
      .               // inlined from `count_is_zero`.
      .               #[inline(never)]
-- line 488 ----------------------------------------
-- line 529 ----------------------------------------
      .               //
      .               //      1. The closure didn't panic, in which case the return value was
      .               //         filled in. We move it out of `data.r` and return it.
      .               //      2. The closure panicked, in which case the panic payload was
      .               //         filled in. We move it out of `data.p` and return it.
      .               //
      .               // Once we stack all that together we should have the "most efficient'
      .               // method of calling a catch panic whilst juggling ownership.
     36 ( 0.00%)      let mut data = Data { f: ManuallyDrop::new(f) };
     72 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (6x)
      .           
     24 ( 0.00%)      let data_ptr = (&raw mut data) as *mut u8;
      .               // SAFETY:
      .               //
      .               // Access to the union's fields: this is `std` and we know that the `r#try`
      .               // intrinsic fills in the `r` or `p` union field based on its return value.
      .               //
      .               // The call to `intrinsics::catch_unwind` is made safe by:
      .               // - `do_call`, the first argument, can be called with the initial `data_ptr`.
      .               // - `do_catch`, the second argument, can be called with the `data_ptr` as well.
      .               // See their safety preconditions for more information
      .               unsafe {
     96 ( 0.00%)          return if intrinsics::catch_unwind(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {
117,396,722 (99.35%)  => ???:__rust_try (6x)
     30 ( 0.00%)              Ok(ManuallyDrop::into_inner(data.r))
      .                   } else {
      .                       Err(ManuallyDrop::into_inner(data.p))
      .                   };
      .               }
      .           
      .               // We consider unwinding to be rare, so mark this function as cold. However,
      .               // do not mark it no-inline -- that decision is best to leave to the
      .               // optimizer (in most cases this function is not inlined even as a normal,
-- line 559 ----------------------------------------
-- line 573 ----------------------------------------
      .               // SAFETY:
      .               // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`
      .               // Its must contains a valid `f` (type: F) value that can be use to fill
      .               // `data.r`.
      .               //
      .               // This function cannot be marked as `unsafe` because `intrinsics::catch_unwind`
      .               // expects normal function pointers.
      .               #[inline]
     30 ( 0.00%)      fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {
      .                   // SAFETY: this is the responsibility of the caller, see above.
      .                   unsafe {
     12 ( 0.00%)              let data = data as *mut Data<F, R>;
      .                       let data = &mut (*data);
     12 ( 0.00%)              let f = ManuallyDrop::take(&mut data.f);
     18 ( 0.00%)              data.r = ManuallyDrop::new(f());
117,396,734 (99.35%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic/unwind_safe.rs:<core::panic::unwind_safe::AssertUnwindSafe<F> as core::ops::function::FnOnce<()>>::call_once (12x)
      .                   }
     24 ( 0.00%)      }
      .           
      .               // We *do* want this part of the catch to be inlined: this allows the
      .               // compiler to properly track accesses to the Data union and optimize it
      .               // away most of the time.
      .               //
      .               // SAFETY:
      .               // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`
      .               // Since this uses `cleanup` it also hinges on a correct implementation of
-- line 597 ----------------------------------------
-- line 614 ----------------------------------------
      .                       data.p = ManuallyDrop::new(obj);
      .                   }
      .               }
      .           }
      .           
      .           /// Determines whether the current thread is unwinding because of panic.
      .           #[inline]
      .           pub fn panicking() -> bool {
 96,009 ( 0.08%)      !panic_count::count_is_zero()
      .           }
      .           
      .           /// Entry point of panics from the core crate (`panic_impl` lang item).
      .           #[cfg(not(any(test, doctest)))]
      .           #[panic_handler]
      .           pub fn begin_panic_handler(info: &core::panic::PanicInfo<'_>) -> ! {
      .               struct FormatStringPayload<'a> {
      .                   inner: &'a core::panic::PanicMessage<'a>,
-- line 630 ----------------------------------------

 32,009 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs
--------------------------------------------------------------------------------
Ir                 

-- line 421 ----------------------------------------
        .               /// let atomic_true = AtomicBool::new(true);
        .               /// let atomic_false = AtomicBool::new(false);
        .               /// ```
        .               #[inline]
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[rustc_const_stable(feature = "const_atomic_new", since = "1.24.0")]
        .               #[must_use]
        .               pub const fn new(v: bool) -> AtomicBool {
        3 ( 0.00%)          AtomicBool { v: UnsafeCell::new(v as u8) }
        .               }
        .           
        .               /// Creates a new `AtomicBool` from a pointer.
        .               ///
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// use std::sync::atomic::{self, AtomicBool};
-- line 437 ----------------------------------------
-- line 615 ----------------------------------------
        .               ///
        .               /// let some_bool = AtomicBool::new(true);
        .               ///
        .               /// assert_eq!(some_bool.load(Ordering::Relaxed), true);
        .               /// ```
        .               #[inline]
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
   33,247 ( 0.03%)      pub fn load(&self, order: Ordering) -> bool {
        .                   // SAFETY: any data races are prevented by atomic intrinsics and the raw
        .                   // pointer passed in is valid because we got it from a reference.
   97,564 ( 0.08%)          unsafe { atomic_load(self.v.get(), order) != 0 }
  736,069 ( 0.62%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_load (32,003x)
      933 ( 0.00%)      }
        .           
        .               /// Stores a value into the bool.
        .               ///
        .               /// `store` takes an [`Ordering`] argument which describes the memory ordering
        .               /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].
        .               ///
        .               /// # Panics
        .               ///
-- line 635 ----------------------------------------
-- line 643 ----------------------------------------
        .               /// let some_bool = AtomicBool::new(true);
        .               ///
        .               /// some_bool.store(false, Ordering::Relaxed);
        .               /// assert_eq!(some_bool.load(Ordering::Relaxed), false);
        .               /// ```
        .               #[inline]
        .               #[stable(feature = "rust1", since = "1.0.0")]
        .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
   64,014 ( 0.05%)      pub fn store(&self, val: bool, order: Ordering) {
        .                   // SAFETY: any data races are prevented by atomic intrinsics and the raw
        .                   // pointer passed in is valid because we got it from a reference.
        .                   unsafe {
        5 ( 0.00%)              atomic_store(self.v.get(), val as u8, order);
       24 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_store (1x)
        .                   }
        2 ( 0.00%)      }
        .           
        .               /// Stores a value into the bool, returning the previous value.
        .               ///
        .               /// `swap` takes an [`Ordering`] argument which describes the memory ordering
        .               /// of this operation. All ordering modes are possible. Note that using
        .               /// [`Acquire`] makes the store part of this operation [`Relaxed`], and
        .               /// using [`Release`] makes the load part [`Relaxed`].
        .               ///
-- line 665 ----------------------------------------
-- line 2347 ----------------------------------------
        .               /// # Examples
        .               ///
        .               /// ```
        .               /// use std::sync::atomic::AtomicBool;
        .               /// let atomic_bool = AtomicBool::from(true);
        .               /// assert_eq!(format!("{atomic_bool:?}"), "true")
        .               /// ```
        .               #[inline]
        4 ( 0.00%)      fn from(b: bool) -> Self {
        .                   Self::new(b)
        2 ( 0.00%)      }
        .           }
        .           
        .           #[cfg(target_has_atomic_load_store = "ptr")]
        .           #[stable(feature = "atomic_from", since = "1.23.0")]
        .           impl<T> From<*mut T> for AtomicPtr<T> {
        .               /// Converts a `*mut T` into an `AtomicPtr<T>`.
        .               #[inline]
        .               fn from(p: *mut T) -> Self {
-- line 2365 ----------------------------------------
-- line 2464 ----------------------------------------
        .                       #[doc = concat!($extra_feature, "use std::sync::atomic::", stringify!($atomic_type), ";")]
        .                       ///
        .                       #[doc = concat!("let atomic_forty_two = ", stringify!($atomic_type), "::new(42);")]
        .                       /// ```
        .                       #[inline]
        .                       #[$stable]
        .                       #[$const_stable_new]
        .                       #[must_use]
    1,062 ( 0.00%)              pub const fn new(v: $int_type) -> Self {
    1,047 ( 0.00%)                  Self {v: UnsafeCell::new(v)}
    2,060 ( 0.00%)              }
        .           
        .                       /// Creates a new reference to an atomic integer from a pointer.
        .                       ///
        .                       /// # Examples
        .                       ///
        .                       /// ```
        .                       #[doc = concat!($extra_feature, "use std::sync::atomic::{self, ", stringify!($atomic_type), "};")]
        .                       ///
-- line 2482 ----------------------------------------
-- line 2690 ----------------------------------------
        .                       ///
        .                       #[doc = concat!("let some_var = ", stringify!($atomic_type), "::new(5);")]
        .                       ///
        .                       /// assert_eq!(some_var.load(Ordering::Relaxed), 5);
        .                       /// ```
        .                       #[inline]
        .                       #[$stable]
        .                       #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
  578,522 ( 0.49%)              pub fn load(&self, order: Ordering) -> $int_type {
        .                           // SAFETY: data races are prevented by atomic intrinsics.
  705,980 ( 0.60%)                  unsafe { atomic_load(self.v.get(), order) }
  736,069 ( 0.62%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_load (32,003x)
  257,252 ( 0.22%)              }
        .           
        .                       /// Stores a value into the atomic integer.
        .                       ///
        .                       /// `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.
        .                       ///  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].
        .                       ///
        .                       /// # Panics
        .                       ///
-- line 2709 ----------------------------------------
-- line 2717 ----------------------------------------
        .                       #[doc = concat!("let some_var = ", stringify!($atomic_type), "::new(5);")]
        .                       ///
        .                       /// some_var.store(10, Ordering::Relaxed);
        .                       /// assert_eq!(some_var.load(Ordering::Relaxed), 10);
        .                       /// ```
        .                       #[inline]
        .                       #[$stable]
        .                       #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
  320,070 ( 0.27%)              pub fn store(&self, val: $int_type, order: Ordering) {
        .                           // SAFETY: data races are prevented by atomic intrinsics.
  192,071 ( 0.16%)                  unsafe { atomic_store(self.v.get(), val, order); }
       24 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_store (1x)
  128,016 ( 0.11%)              }
        .           
        .                       /// Stores a value into the atomic integer, returning the previous value.
        .                       ///
        .                       /// `swap` takes an [`Ordering`] argument which describes the memory ordering
        .                       /// of this operation. All ordering modes are possible. Note that using
        .                       /// [`Acquire`] makes the store part of this operation [`Relaxed`], and
        .                       /// using [`Release`] makes the load part [`Relaxed`].
        .                       ///
-- line 2736 ----------------------------------------
-- line 2745 ----------------------------------------
        .                       #[doc = concat!("let some_var = ", stringify!($atomic_type), "::new(5);")]
        .                       ///
        .                       /// assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);
        .                       /// ```
        .                       #[inline]
        .                       #[$stable]
        .                       #[$cfg_cas]
        .                       #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
   64,006 ( 0.05%)              pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {
        .                           // SAFETY: data races are prevented by atomic intrinsics.
   32,003 ( 0.03%)                  unsafe { atomic_swap(self.v.get(), val, order) }
        .                       }
        .           
        .                       /// Stores a value into the atomic integer if the current value is the same as
        .                       /// the `current` value.
        .                       ///
        .                       /// The return value is always the previous value. If it is equal to `current`, then the
        .                       /// value was updated.
        .                       ///
-- line 2763 ----------------------------------------
-- line 2863 ----------------------------------------
        .                       ///                                      Ordering::Acquire),
        .                       ///            Err(10));
        .                       /// assert_eq!(some_var.load(Ordering::Relaxed), 10);
        .                       /// ```
        .                       #[inline]
        .                       #[$stable_cxchg]
        .                       #[$cfg_cas]
        .                       #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
  448,000 ( 0.38%)              pub fn compare_exchange(&self,
   32,009 ( 0.03%)                                      current: $int_type,
   32,009 ( 0.03%)                                      new: $int_type,
   32,009 ( 0.03%)                                      success: Ordering,
   32,009 ( 0.03%)                                      failure: Ordering) -> Result<$int_type, $int_type> {
        .                           // SAFETY: data races are prevented by atomic intrinsics.
  576,084 ( 0.49%)                  unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }
1,632,153 ( 1.38%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:core::sync::atomic::atomic_compare_exchange (32,003x)
  128,000 ( 0.11%)              }
        .           
        .                       /// Stores a value into the atomic integer if the current value is the same as
        .                       /// the `current` value.
        .                       ///
        .                       #[doc = concat!("Unlike [`", stringify!($atomic_type), "::compare_exchange`],")]
        .                       /// this function is allowed to spuriously fail even
        .                       /// when the comparison succeeds, which can result in more efficient code on some
        .                       /// platforms. The return value is a result indicating whether the new value was
-- line 2886 ----------------------------------------
-- line 2948 ----------------------------------------
        .                       #[doc = concat!("let foo = ", stringify!($atomic_type), "::new(0);")]
        .                       /// assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);
        .                       /// assert_eq!(foo.load(Ordering::SeqCst), 10);
        .                       /// ```
        .                       #[inline]
        .                       #[$stable]
        .                       #[$cfg_cas]
        .                       #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
  192,116 ( 0.16%)              pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {
        .                           // SAFETY: data races are prevented by atomic intrinsics.
   32,058 ( 0.03%)                  unsafe { atomic_add(self.v.get(), val, order) }
   64,000 ( 0.05%)              }
        .           
        .                       /// Subtracts from the current value, returning the previous value.
        .                       ///
        .                       /// This operation wraps around on overflow.
        .                       ///
        .                       /// `fetch_sub` takes an [`Ordering`] argument which describes the memory ordering
        .                       /// of this operation. All ordering modes are possible. Note that using
        .                       /// [`Acquire`] makes the store part of this operation [`Relaxed`], and
-- line 2967 ----------------------------------------
-- line 2978 ----------------------------------------
        .                       #[doc = concat!("let foo = ", stringify!($atomic_type), "::new(20);")]
        .                       /// assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);
        .                       /// assert_eq!(foo.load(Ordering::SeqCst), 10);
        .                       /// ```
        .                       #[inline]
        .                       #[$stable]
        .                       #[$cfg_cas]
        .                       #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      180 ( 0.00%)              pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {
        .                           // SAFETY: data races are prevented by atomic intrinsics.
       90 ( 0.00%)                  unsafe { atomic_sub(self.v.get(), val, order) }
        .                       }
        .           
        .                       /// Bitwise "and" with the current value.
        .                       ///
        .                       /// Performs a bitwise "and" operation on the current value and the argument `val`, and
        .                       /// sets the new value to the result.
        .                       ///
        .                       /// Returns the previous value.
-- line 2996 ----------------------------------------
-- line 3704 ----------------------------------------
        .                   SeqCst => SeqCst,
        .                   Acquire => Acquire,
        .                   AcqRel => Acquire,
        .               }
        .           }
        .           
        .           #[inline]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
  448,113 ( 0.38%)  unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {
        .               // SAFETY: the caller must uphold the safety contract for `atomic_store`.
        .               unsafe {
  320,080 ( 0.27%)          match order {
        2 ( 0.00%)              Relaxed => intrinsics::atomic_store_relaxed(dst, val),
       28 ( 0.00%)              Release => intrinsics::atomic_store_release(dst, val),
   64,001 ( 0.05%)              SeqCst => intrinsics::atomic_store_seqcst(dst, val),
        .                       Acquire => panic!("there is no such thing as an acquire store"),
        .                       AcqRel => panic!("there is no such thing as an acquire-release store"),
        .                   }
        .               }
  128,032 ( 0.11%)  }
        .           
        .           #[inline]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
1,124,790 ( 0.95%)  unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {
        .               // SAFETY: the caller must uphold the safety contract for `atomic_load`.
        .               unsafe {
1,124,790 ( 0.95%)          match order {
  288,981 ( 0.24%)              Relaxed => intrinsics::atomic_load_relaxed(dst),
  289,893 ( 0.25%)              Acquire => intrinsics::atomic_load_acquire(dst),
   64,000 ( 0.05%)              SeqCst => intrinsics::atomic_load_seqcst(dst),
        .                       Release => panic!("there is no such thing as a release load"),
        .                       AcqRel => panic!("there is no such thing as an acquire-release load"),
        .                   }
        .               }
  674,874 ( 0.57%)  }
        .           
        .           #[inline]
        .           #[cfg(target_has_atomic)]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
   64,006 ( 0.05%)  unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        .               // SAFETY: the caller must uphold the safety contract for `atomic_swap`.
        .               unsafe {
        .                   match order {
        .                       Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),
        .                       Acquire => intrinsics::atomic_xchg_acquire(dst, val),
   64,006 ( 0.05%)              Release => intrinsics::atomic_xchg_release(dst, val),
        .                       AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),
        .                       SeqCst => intrinsics::atomic_xchg_seqcst(dst, val),
        .                   }
        .               }
        .           }
        .           
        .           /// Returns the previous value (like __sync_fetch_and_add).
        .           #[inline]
        .           #[cfg(target_has_atomic)]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      116 ( 0.00%)  unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        .               // SAFETY: the caller must uphold the safety contract for `atomic_add`.
        .               unsafe {
  160,000 ( 0.14%)          match order {
   96,232 ( 0.08%)              Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),
        .                       Acquire => intrinsics::atomic_xadd_acquire(dst, val),
        .                       Release => intrinsics::atomic_xadd_release(dst, val),
        .                       AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),
        .                       SeqCst => intrinsics::atomic_xadd_seqcst(dst, val),
        .                   }
        .               }
        .           }
        .           
        .           /// Returns the previous value (like __sync_fetch_and_sub).
        .           #[inline]
        .           #[cfg(target_has_atomic)]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      180 ( 0.00%)  unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {
        .               // SAFETY: the caller must uphold the safety contract for `atomic_sub`.
        .               unsafe {
        .                   match order {
        .                       Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),
        .                       Acquire => intrinsics::atomic_xsub_acquire(dst, val),
      180 ( 0.00%)              Release => intrinsics::atomic_xsub_release(dst, val),
        .                       AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),
        .                       SeqCst => intrinsics::atomic_xsub_seqcst(dst, val),
        .                   }
        .               }
        .           }
        .           
        .           #[inline]
        .           #[cfg(target_has_atomic)]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
  960,090 ( 0.81%)  unsafe fn atomic_compare_exchange<T: Copy>(
        .               dst: *mut T,
        .               old: T,
        .               new: T,
        .               success: Ordering,
        .               failure: Ordering,
        .           ) -> Result<T, T> {
        .               // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.
  672,063 ( 0.57%)      let (val, ok) = unsafe {
  864,081 ( 0.73%)          match (success, failure) {
        .                       (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed_relaxed(dst, old, new),
        .                       (Relaxed, Acquire) => intrinsics::atomic_cxchg_relaxed_acquire(dst, old, new),
        .                       (Relaxed, SeqCst) => intrinsics::atomic_cxchg_relaxed_seqcst(dst, old, new),
  224,063 ( 0.19%)              (Acquire, Relaxed) => intrinsics::atomic_cxchg_acquire_relaxed(dst, old, new),
        .                       (Acquire, Acquire) => intrinsics::atomic_cxchg_acquire_acquire(dst, old, new),
        .                       (Acquire, SeqCst) => intrinsics::atomic_cxchg_acquire_seqcst(dst, old, new),
        .                       (Release, Relaxed) => intrinsics::atomic_cxchg_release_relaxed(dst, old, new),
        .                       (Release, Acquire) => intrinsics::atomic_cxchg_release_acquire(dst, old, new),
        .                       (Release, SeqCst) => intrinsics::atomic_cxchg_release_seqcst(dst, old, new),
        .                       (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_relaxed(dst, old, new),
        .                       (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel_acquire(dst, old, new),
        .                       (AcqRel, SeqCst) => intrinsics::atomic_cxchg_acqrel_seqcst(dst, old, new),
  448,000 ( 0.38%)              (SeqCst, Relaxed) => intrinsics::atomic_cxchg_seqcst_relaxed(dst, old, new),
        .                       (SeqCst, Acquire) => intrinsics::atomic_cxchg_seqcst_acquire(dst, old, new),
        .                       (SeqCst, SeqCst) => intrinsics::atomic_cxchg_seqcst_seqcst(dst, old, new),
        .                       (_, AcqRel) => panic!("there is no such thing as an acquire-release failure ordering"),
        .                       (_, Release) => panic!("there is no such thing as a release failure ordering"),
        .                   }
        .               };
  384,036 ( 0.32%)      if ok { Ok(val) } else { Err(val) }
  384,036 ( 0.32%)  }
        .           
        .           #[inline]
        .           #[cfg(target_has_atomic)]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
        .           unsafe fn atomic_compare_exchange_weak<T: Copy>(
        .               dst: *mut T,
        .               old: T,
        .               new: T,
-- line 3831 ----------------------------------------
-- line 4067 ----------------------------------------
        .           ///         self.flag.store(false, Ordering::Release);
        .           ///     }
        .           /// }
        .           /// ```
        .           #[inline]
        .           #[stable(feature = "rust1", since = "1.0.0")]
        .           #[rustc_diagnostic_item = "fence"]
        .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
       90 ( 0.00%)  pub fn fence(order: Ordering) {
        .               // SAFETY: using an atomic fence is safe.
        .               unsafe {
        .                   match order {
        .                       Acquire => intrinsics::atomic_fence_acquire(),
        .                       Release => intrinsics::atomic_fence_release(),
        .                       AcqRel => intrinsics::atomic_fence_acqrel(),
        .                       SeqCst => intrinsics::atomic_fence_seqcst(),
        .                       Relaxed => panic!("there is no such thing as a relaxed fence"),
-- line 4083 ----------------------------------------

1,634,992 ( 1.38%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs
--------------------------------------------------------------------------------
Ir               

-- line 106 ----------------------------------------
      .           ///
      .           /// [`slice::from_raw_parts`]: crate::slice::from_raw_parts
      .           #[unstable(feature = "ptr_metadata", issue = "81513")]
      .           #[inline]
      .           pub const fn from_raw_parts<T: ?Sized>(
      .               data_pointer: *const impl Thin,
      .               metadata: <T as Pointee>::Metadata,
      .           ) -> *const T {
192,030 ( 0.16%)      aggregate_raw_ptr(data_pointer, metadata)
      .           }
      .           
      .           /// Performs the same functionality as [`from_raw_parts`], except that a
      .           /// raw `*mut` pointer is returned, as opposed to a raw `*const` pointer.
      .           ///
      .           /// See the documentation of [`from_raw_parts`] for more details.
      .           #[unstable(feature = "ptr_metadata", issue = "81513")]
      .           #[inline]
      .           pub const fn from_raw_parts_mut<T: ?Sized>(
      .               data_pointer: *mut impl Thin,
      .               metadata: <T as Pointee>::Metadata,
      .           ) -> *mut T {
 64,064 ( 0.05%)      aggregate_raw_ptr(data_pointer, metadata)
      .           }
      .           
      .           /// The metadata for a `Dyn = dyn SomeTrait` trait object type.
      .           ///
      .           /// It is a pointer to a vtable (virtual call table)
      .           /// that represents all the necessary information
      .           /// to manipulate the concrete type stored inside a trait object.
      .           /// The vtable notably contains:
-- line 135 ----------------------------------------

 32,029 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs
--------------------------------------------------------------------------------
Ir               

-- line 47 ----------------------------------------
      .                           match (ptr).guaranteed_eq(null_mut()) {
      .                               Some(res) => res,
      .                               // To remain maximally convervative, we stop execution when we don't
      .                               // know whether the pointer is null or not.
      .                               // We can *not* return `false` here, that would be unsound in `NonNull::new`!
      .                               None => panic!("null-ness of this pointer cannot be determined in const context"),
      .                           }
      .                       } else {
448,160 ( 0.38%)                  ptr.addr() == 0
      .                       }
      .                   )
      .               }
      .           
      .               /// Casts to a pointer of another type.
      .               #[stable(feature = "ptr_cast", since = "1.38.0")]
      .               #[rustc_const_stable(feature = "const_ptr_cast", since = "1.38.0")]
      .               #[rustc_diagnostic_item = "const_ptr_cast"]
      .               #[inline(always)]
      .               pub const fn cast<U>(self) -> *const U {
      1 ( 0.00%)          self as _
      .               }
      .           
      .               /// Uses the address value in a new pointer of another type.
      .               ///
      .               /// This operation will ignore the address part of its `meta` operand and discard existing
      .               /// metadata of `self`. For pointers to a sized types (thin pointers), this has the same effect
      .               /// as a simple cast. For pointers to an unsized type (fat pointers) this recombines the address
      .               /// with new metadata such as slice lengths or `dyn`-vtable.
-- line 74 ----------------------------------------
-- line 163 ----------------------------------------
      .               #[inline(always)]
      .               #[stable(feature = "strict_provenance", since = "1.84.0")]
      .               pub fn addr(self) -> usize {
      .                   // A pointer-to-integer transmute currently has exactly the right semantics: it returns the
      .                   // address without exposing the provenance. Note that this is *not* a stable guarantee about
      .                   // transmute semantics, it relies on sysroot crates having special status.
      .                   // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the
      .                   // provenance).
     30 ( 0.00%)          unsafe { mem::transmute(self.cast::<()>()) }
      .               }
      .           
      .               /// Exposes the ["provenance"][crate::ptr#provenance] part of the pointer for future use in
      .               /// [`with_exposed_provenance`] and returns the "address" portion.
      .               ///
      .               /// This is equivalent to `self as usize`, which semantically discards provenance information.
      .               /// Furthermore, this (like the `as` cast) has the implicit side-effect of marking the
      .               /// provenance as 'exposed', so on platforms that support it you can later call
-- line 179 ----------------------------------------
-- line 291 ----------------------------------------
      .               /// }
      .               /// ```
      .               #[stable(feature = "ptr_as_ref", since = "1.9.0")]
      .               #[rustc_const_stable(feature = "const_ptr_is_null", since = "1.84.0")]
      .               #[inline]
      .               pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
      .                   // SAFETY: the caller must guarantee that `self` is valid
      .                   // for a reference if it isn't null.
      3 ( 0.00%)          if self.is_null() { None } else { unsafe { Some(&*self) } }
      .               }
      .           
      .               /// Returns a shared reference to the value behind the pointer.
      .               /// If the pointer may be null or the value may be uninitialized, [`as_uninit_ref`] must be used instead.
      .               /// If the pointer may be null, but the value is known to have been initialized, [`as_ref`] must be used instead.
      .               ///
      .               /// [`as_ref`]: #method.as_ref
      .               /// [`as_uninit_ref`]: #method.as_uninit_ref
-- line 307 ----------------------------------------
-- line 525 ----------------------------------------
      .               /// }
      .               /// assert_eq!(out.as_str(), "1, 3, 5, ");
      .               /// # std::fmt::Result::Ok(())
      .               /// ```
      .               #[stable(feature = "ptr_wrapping_offset", since = "1.16.0")]
      .               #[must_use = "returns a new pointer rather than modifying its argument"]
      .               #[rustc_const_stable(feature = "const_ptr_offset", since = "1.61.0")]
      .               #[inline(always)]
 64,012 ( 0.05%)      pub const fn wrapping_offset(self, count: isize) -> *const T
      .               where
      .                   T: Sized,
      .               {
      .                   // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.
      .                   unsafe { intrinsics::arith_offset(self, count) }
      .               }
      .           
      .               /// Adds a signed offset in bytes to a pointer using wrapping arithmetic.
-- line 541 ----------------------------------------
-- line 777 ----------------------------------------
      .               {
      .                   #[rustc_allow_const_fn_unstable(const_eval_select)]
      .                   const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {
      .                       const_eval_select!(
      .                           @capture { this: *const (), origin: *const () } -> bool:
      .                           if const {
      .                               true
      .                           } else {
 64,305 ( 0.05%)                      this >= origin
      .                           }
      .                       )
      .                   }
      .           
      .                   ub_checks::assert_unsafe_precondition!(
      .                       check_language_ub,
      .                       "ptr::sub_ptr requires `self >= origin`",
      .                       (
      .                           this: *const () = self as *const (),
      .                           origin: *const () = origin as *const (),
 64,305 ( 0.05%)              ) => runtime_ptr_ge(this, origin)
      .                   );
      .           
      .                   let pointee_size = mem::size_of::<T>();
 64,305 ( 0.05%)          assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);
      .                   // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.
257,226 ( 0.22%)          unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }
      .               }
      .           
      .               /// Calculates the distance between two pointers within the same allocation, *where it's known that
      .               /// `self` is equal to or greater than `origin`*. The returned value is in
      .               /// units of **bytes**.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
      .               /// using [`sub_ptr`][pointer::sub_ptr] on it. See that method for
-- line 810 ----------------------------------------
-- line 925 ----------------------------------------
      .               ///     assert_eq!(*ptr.add(2), b'3');
      .               /// }
      .               /// ```
      .               #[stable(feature = "pointer_methods", since = "1.26.0")]
      .               #[must_use = "returns a new pointer rather than modifying its argument"]
      .               #[rustc_const_stable(feature = "const_ptr_offset", since = "1.61.0")]
      .               #[inline(always)]
      .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      3 ( 0.00%)      pub const unsafe fn add(self, count: usize) -> Self
      .               where
      .                   T: Sized,
      .               {
      .                   #[cfg(debug_assertions)]
      .                   #[inline]
      .                   #[rustc_allow_const_fn_unstable(const_eval_select)]
      .                   const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {
      .                       const_eval_select!(
-- line 941 ----------------------------------------
-- line 959 ----------------------------------------
      .                       (
      .                           this: *const () = self as *const (),
      .                           count: usize = count,
      .                           size: usize = size_of::<T>(),
      .                       ) => runtime_add_nowrap(this, count, size)
      .                   );
      .           
      .                   // SAFETY: the caller must uphold the safety contract for `offset`.
     21 ( 0.00%)          unsafe { intrinsics::offset(self, count) }
      .               }
      .           
      .               /// Adds an unsigned offset in bytes to a pointer.
      .               ///
      .               /// `count` is in units of bytes.
      .               ///
      .               /// This is purely a convenience for casting to a `u8` pointer and
      .               /// using [add][pointer::add] on it. See that method for documentation
-- line 975 ----------------------------------------
-- line 1228 ----------------------------------------
      .               /// }
      .               /// assert_eq!(out, "5, 3, 1, ");
      .               /// # std::fmt::Result::Ok(())
      .               /// ```
      .               #[stable(feature = "pointer_methods", since = "1.26.0")]
      .               #[must_use = "returns a new pointer rather than modifying its argument"]
      .               #[rustc_const_stable(feature = "const_ptr_offset", since = "1.61.0")]
      .               #[inline(always)]
 64,012 ( 0.05%)      pub const fn wrapping_sub(self, count: usize) -> Self
      .               where
      .                   T: Sized,
      .               {
      .                   self.wrapping_offset((count as isize).wrapping_neg())
      .               }
      .           
      .               /// Subtracts an unsigned offset in bytes from a pointer using wrapping arithmetic.
      .               ///
-- line 1244 ----------------------------------------
-- line 1248 ----------------------------------------
      .               /// using [wrapping_sub][pointer::wrapping_sub] on it. See that method for documentation.
      .               ///
      .               /// For non-`Sized` pointees this operation changes only the data pointer,
      .               /// leaving the metadata untouched.
      .               #[must_use]
      .               #[inline(always)]
      .               #[stable(feature = "pointer_byte_offsets", since = "1.75.0")]
      .               #[rustc_const_stable(feature = "const_pointer_byte_offsets", since = "1.75.0")]
 64,012 ( 0.05%)      pub const fn wrapping_byte_sub(self, count: usize) -> Self {
      .                   self.cast::<u8>().wrapping_sub(count).with_metadata_of(self)
      .               }
      .           
      .               /// Reads the value from `self` without moving it. This leaves the
      .               /// memory in `self` unchanged.
      .               ///
      .               /// See [`ptr::read`] for safety concerns and examples.
      .               ///
-- line 1264 ----------------------------------------
-- line 1392 ----------------------------------------
      .               ///     // while the pointer can be aligned via `offset`, it would point
      .               ///     // outside the allocation
      .               /// }
      .               /// # }
      .               /// ```
      .               #[must_use]
      .               #[inline]
      .               #[stable(feature = "align_offset", since = "1.36.0")]
      6 ( 0.00%)      pub fn align_offset(self, align: usize) -> usize
      .               where
      .                   T: Sized,
      .               {
      .                   if !align.is_power_of_two() {
      .                       panic!("align_offset: align is not a power-of-two");
      .                   }
      .           
      .                   // SAFETY: `align` has been checked to be a power of 2 above
-- line 1408 ----------------------------------------
-- line 1471 ----------------------------------------
      .               /// assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));
      .               ///
      .               /// assert_ne!(ptr.is_aligned_to(8), ptr.wrapping_add(1).is_aligned_to(8));
      .               /// ```
      .               #[must_use]
      .               #[inline]
      .               #[unstable(feature = "pointer_is_aligned_to", issue = "96284")]
      .               pub fn is_aligned_to(self, align: usize) -> bool {
448,160 ( 0.38%)          if !align.is_power_of_two() {
      .                       panic!("is_aligned_to: align is not a power-of-two");
      .                   }
      .           
448,180 ( 0.38%)          self.addr() & (align - 1) == 0
      .               }
      .           }
      .           
      .           impl<T> *const [T] {
      .               /// Returns the length of a raw slice.
      .               ///
      .               /// The returned value is the number of **elements**, not the number of bytes.
      .               ///
-- line 1491 ----------------------------------------

800,832 ( 0.68%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs
--------------------------------------------------------------------------------
Ir               

-- line 314 ----------------------------------------
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<I: Iterator> IntoIterator for I {
      .               type Item = I::Item;
      .               type IntoIter = I;
      .           
      .               #[inline]
160,045 ( 0.14%)      fn into_iter(self) -> I {
480,054 ( 0.41%)          self
384,000 ( 0.32%)  => ???:__memcpy_avx_unaligned_erms (32,000x)
128,018 ( 0.11%)      }
      .           }
      .           
      .           /// Extend a collection with the contents of an iterator.
      .           ///
      .           /// Iterators produce a series of values, and collections can also be thought
      .           /// of as a series of values. The `Extend` trait bridges this gap, allowing you
      .           /// to extend a collection by including the contents of that iterator. When
      .           /// extending a collection with an already existing key, that entry is updated
-- line 332 ----------------------------------------

 32,000 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs
--------------------------------------------------------------------------------
Ir               

-- line 556 ----------------------------------------
      .               ///
      .               /// let x: Result<i32, &str> = Err("Some error message");
      .               /// assert_eq!(x.is_ok(), false);
      .               /// ```
      .               #[must_use = "if you intended to assert that this is ok, consider `.unwrap()` instead"]
      .               #[rustc_const_stable(feature = "const_result_basics", since = "1.48.0")]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
 64,000 ( 0.05%)      pub const fn is_ok(&self) -> bool {
 32,008 ( 0.03%)          matches!(*self, Ok(_))
128,000 ( 0.11%)      }
      .           
      .               /// Returns `true` if the result is [`Ok`] and the value inside of it matches a predicate.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// let x: Result<u32, &str> = Ok(2);
      .               /// assert_eq!(x.is_ok_and(|x| x > 1), true);
-- line 574 ----------------------------------------
-- line 600 ----------------------------------------
      .               /// let x: Result<i32, &str> = Err("Some error message");
      .               /// assert_eq!(x.is_err(), true);
      .               /// ```
      .               #[must_use = "if you intended to assert that this is err, consider `.unwrap_err()` instead"]
      .               #[rustc_const_stable(feature = "const_result_basics", since = "1.48.0")]
      .               #[inline]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub const fn is_err(&self) -> bool {
 32,004 ( 0.03%)          !self.is_ok()
      .               }
      .           
      .               /// Returns `true` if the result is [`Err`] and the value inside of it matches a predicate.
      .               ///
      .               /// # Examples
      .               ///
      .               /// ```
      .               /// use std::io::{Error, ErrorKind};
-- line 616 ----------------------------------------
-- line 1047 ----------------------------------------
      .               ///
      .               /// For more detail on expect message styles and the reasoning behind our recommendation please
      .               /// refer to the section on ["Common Message
      .               /// Styles"](../../std/error/index.html#common-message-styles) in the
      .               /// [`std::error`](../../std/error/index.html) module docs.
      .               #[inline]
      .               #[track_caller]
      .               #[stable(feature = "result_expect", since = "1.4.0")]
     54 ( 0.00%)      pub fn expect(self, msg: &str) -> T
      .               where
      .                   E: fmt::Debug,
      .               {
     42 ( 0.00%)          match self {
     36 ( 0.00%)              Ok(t) => t,
      .                       Err(e) => unwrap_failed(msg, &e),
      .                   }
     12 ( 0.00%)      }
      .           
      .               /// Returns the contained [`Ok`] value, consuming the `self` value.
      .               ///
      .               /// Because this function may panic, its use is generally discouraged.
      .               /// Panics are meant for unrecoverable errors, and
      .               /// [may abort the entire program][panic-abort].
      .               ///
      .               /// Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching
-- line 1071 ----------------------------------------
-- line 1099 ----------------------------------------
      .               /// ```
      .               #[inline(always)]
      .               #[track_caller]
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               pub fn unwrap(self) -> T
      .               where
      .                   E: fmt::Debug,
      .               {
 64,036 ( 0.05%)          match self {
160,015 ( 0.14%)              Ok(t) => t,
      .                       Err(e) => unwrap_failed("called `Result::unwrap()` on an `Err` value", &e),
      .                   }
      6 ( 0.00%)      }
      .           
      .               /// Returns the contained [`Ok`] value or a default
      .               ///
      .               /// Consumes the `self` argument then, if [`Ok`], returns the contained
      .               /// value, otherwise if [`Err`], returns the default value for that
      .               /// type.
      .               ///
      .               /// # Examples
-- line 1119 ----------------------------------------
-- line 1993 ----------------------------------------
      .           
      .               #[inline]
      .               fn from_output(output: Self::Output) -> Self {
      .                   Ok(output)
      .               }
      .           
      .               #[inline]
      .               fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {
     75 ( 0.00%)          match self {
 96,237 ( 0.08%)              Ok(v) => ControlFlow::Continue(v),
      .                       Err(e) => ControlFlow::Break(Err(e)),
      .                   }
      .               }
      .           }
      .           
      .           #[unstable(feature = "try_trait_v2", issue = "84277")]
      .           impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>> for Result<T, F> {
      .               #[inline]
-- line 2010 ----------------------------------------

 32,038 ( 0.03%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: src/storage/ring_buffer.rs
--------------------------------------------------------------------------------
Ir               

-- line 3 ----------------------------------------
      .           
      .           #[derive(Debug)]
      .           pub struct RingBuffer<T> {
      .               storage: Vec<UnsafeCell<T>>,
      .               size: usize,
      .           }
      .           
      .           impl <T: Send + Sync + Default> RingBuffer<T> {
      5 ( 0.00%)      pub fn new(size: usize) -> Self {
     10 ( 0.00%)          assert!(size != 0 && size & (size - 1) == 0, "ring buffer should be power of 2");
      6 ( 0.00%)          let mut data = Vec::with_capacity(size);
    315 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T>::with_capacity (1x)
      .           
  8,206 ( 0.01%)          for _ in 0..size {
 53,269 ( 0.05%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:core::iter::range::<impl core::iter::traits::iterator::Iterator for core::ops::range::Range<A>>::next (1,025x)
      5 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:<I as core::iter::traits::collect::IntoIterator>::into_iter (1x)
  9,216 ( 0.01%)              data.push(UnsafeCell::new(T::default()));
 40,960 ( 0.03%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:alloc::vec::Vec<T,A>::push (1,024x)
  3,072 ( 0.00%)  => /home/akshay_kumar/Code/OSS/rust/oxidater/samples/multi_producer_sample.rs:<multi_producer::Event as core::default::Default>::default (1,024x)
      .                   }
      .           
      7 ( 0.00%)          Self {
      6 ( 0.00%)              storage: data,
      .                       size
      .                   }
      2 ( 0.00%)      }
      .           }
      .           
      .           impl<'a, T: Send + Sync> DataStorage<T> for RingBuffer<T> {
320,000 ( 0.27%)      unsafe fn get_data(&self, s: Sequence) -> &T {
576,000 ( 0.49%)          let index = (s as usize) & (self.size - 1);
512,000 ( 0.43%)          let data = self.storage.get_unchecked(index);
5,952,000 ( 5.04%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::deref::Deref>::deref (64,000x)
2,176,000 ( 1.84%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:core::slice::<impl [T]>::get_unchecked (64,000x)
384,000 ( 0.32%)          &*data.get()
128,000 ( 0.11%)      }
      .           
160,000 ( 0.14%)      unsafe fn get_data_mut(&self, s: Sequence) -> &mut T {
288,000 ( 0.24%)          let index = (s as usize) & (self.size - 1);
256,000 ( 0.22%)          let data = self.storage.get_unchecked(index);
2,976,000 ( 2.52%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:<alloc::vec::Vec<T,A> as core::ops::deref::Deref>::deref (32,000x)
1,088,000 ( 0.92%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:core::slice::<impl [T]>::get_unchecked (32,000x)
192,000 ( 0.16%)          &mut *data.get()
 64,000 ( 0.05%)      }
      .           
      1 ( 0.00%)      fn capacity(&self) -> usize {
      1 ( 0.00%)          self.size
      1 ( 0.00%)      }
      .           
      .               fn len(&self) -> usize {
      .                   self.size
      .               }
      .           }
      .           
      .           unsafe impl<T: Send> Send for RingBuffer<T> {}
      .           unsafe impl<T: Sync> Sync for RingBuffer<T> {}
-- line 49 ----------------------------------------

393,228 ( 0.33%)  <counts for unidentified lines in src/storage/ring_buffer.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs
--------------------------------------------------------------------------------
Ir              

-- line 266 ----------------------------------------
     .               /// ```
     .               #[cfg(not(no_global_oom_handling))]
     .               #[inline(always)]
     .               #[stable(feature = "rust1", since = "1.0.0")]
     .               #[must_use]
     .               #[rustc_diagnostic_item = "box_new"]
     .               #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
     .               pub fn new(x: T) -> Self {
   199 ( 0.00%)          return box_new(x);
   365 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:alloc::alloc::exchange_malloc (2x)
    13 ( 0.00%)      }
     .           
     .               /// Constructs a new box with uninitialized contents.
     .               ///
     .               /// # Examples
     .               ///
     .               /// ```
     .               /// let mut five = Box::<u32>::new_uninit();
     .               /// // Deferred initialization:
-- line 283 ----------------------------------------
-- line 472 ----------------------------------------
     .               /// let five = unsafe { five.assume_init() };
     .               ///
     .               /// assert_eq!(*five, 5)
     .               /// ```
     .               #[unstable(feature = "allocator_api", issue = "32838")]
     .               #[cfg(not(no_global_oom_handling))]
     .               #[must_use]
     .               // #[unstable(feature = "new_uninit", issue = "63291")]
     1 ( 0.00%)      pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
     .               where
     .                   A: Allocator,
     .               {
     .                   let layout = Layout::new::<mem::MaybeUninit<T>>();
     .                   // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
     .                   // That would make code size bigger.
     9 ( 0.00%)          match Box::try_new_uninit_in(alloc) {
   438 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:alloc::boxed::Box<T,A>::try_new_uninit_in (1x)
     2 ( 0.00%)              Ok(m) => m,
     .                       Err(_) => handle_alloc_error(layout),
     .                   }
     2 ( 0.00%)      }
     .           
     .               /// Constructs a new box with uninitialized contents in the provided allocator,
     .               /// returning an error if the allocation fails
     .               ///
     .               /// # Examples
     .               ///
     .               /// ```
     .               /// #![feature(allocator_api)]
-- line 499 ----------------------------------------
-- line 505 ----------------------------------------
     .               /// five.write(5);
     .               /// let five = unsafe { five.assume_init() };
     .               ///
     .               /// assert_eq!(*five, 5);
     .               /// # Ok::<(), std::alloc::AllocError>(())
     .               /// ```
     .               #[unstable(feature = "allocator_api", issue = "32838")]
     .               // #[unstable(feature = "new_uninit", issue = "63291")]
     1 ( 0.00%)      pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
     .               where
     .                   A: Allocator,
     .               {
     1 ( 0.00%)          let ptr = if T::IS_ZST {
     .                       NonNull::dangling()
     .                   } else {
     .                       let layout = Layout::new::<mem::MaybeUninit<T>>();
    10 ( 0.00%)              alloc.allocate(layout)?.cast()
   358 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::alloc::Global as core::alloc::Allocator>::allocate (1x)
     .                   };
     4 ( 0.00%)          unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
     3 ( 0.00%)      }
     .           
     .               /// Constructs a new `Box` with uninitialized contents, with the memory
     .               /// being filled with `0` bytes in the provided allocator.
     .               ///
     .               /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage
     .               /// of this method.
     .               ///
     .               /// # Examples
-- line 532 ----------------------------------------
-- line 932 ----------------------------------------
     .               /// let five: Box<u32> = unsafe { five.assume_init() };
     .               ///
     .               /// assert_eq!(*five, 5)
     .               /// ```
     .               #[stable(feature = "new_uninit", since = "1.82.0")]
     .               #[inline]
     .               pub unsafe fn assume_init(self) -> Box<T, A> {
     .                   let (raw, alloc) = Box::into_raw_with_allocator(self);
     1 ( 0.00%)          unsafe { Box::from_raw_in(raw as *mut T, alloc) }
     .               }
     .           
     .               /// Writes the value and converts to `Box<T, A>`.
     .               ///
     .               /// This method converts the box similarly to [`Box::assume_init`] but
     .               /// writes `value` into it before conversion thus guaranteeing safety.
     .               /// In some scenarios use of this method may improve performance because
     .               /// the compiler may be able to optimize copying from stack.
-- line 948 ----------------------------------------
-- line 1165 ----------------------------------------
     .               /// ```
     .               ///
     .               /// [memory layout]: self#memory-layout
     .               /// [`Layout`]: crate::Layout
     .               #[unstable(feature = "allocator_api", issue = "32838")]
     .               #[rustc_const_unstable(feature = "const_box", issue = "92521")]
     .               #[inline]
     .               pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
    18 ( 0.00%)          Box(unsafe { Unique::new_unchecked(raw) }, alloc)
     .               }
     .           
     .               /// Constructs a box from a `NonNull` pointer in the given allocator.
     .               ///
     .               /// After calling this function, the `NonNull` pointer is owned by
     .               /// the resulting `Box`. Specifically, the `Box` destructor will call
     .               /// the destructor of `T` and free the allocated memory. For this
     .               /// to be safe, the memory must have been allocated in accordance
-- line 1181 ----------------------------------------
-- line 1395 ----------------------------------------
     .               #[inline]
     .               pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {
     .                   let mut b = mem::ManuallyDrop::new(b);
     .                   // We carefully get the raw pointer out in a way that Miri's aliasing model understands what
     .                   // is happening: using the primitive "deref" of `Box`. In case `A` is *not* `Global`, we
     .                   // want *no* aliasing requirements here!
     .                   // In case `A` *is* `Global`, this does not quite have the right behavior; `into_raw`
     .                   // works around that.
64,019 ( 0.05%)          let ptr = &raw mut **b;
     .                   let alloc = unsafe { ptr::read(&b.1) };
     .                   (ptr, alloc)
     .               }
     .           
     .               /// Consumes the `Box`, returning a wrapped `NonNull` pointer and the allocator.
     .               ///
     .               /// The pointer will be properly aligned.
     .               ///
-- line 1411 ----------------------------------------
-- line 1668 ----------------------------------------
     .                   // additional requirements.
     .                   unsafe { Pin::new_unchecked(boxed) }
     .               }
     .           }
     .           
     .           #[stable(feature = "rust1", since = "1.0.0")]
     .           unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {
     .               #[inline]
    21 ( 0.00%)      fn drop(&mut self) {
     .                   // the T in the Box is dropped by the compiler before the destructor is run
     .           
    33 ( 0.00%)          let ptr = self.0;
     .           
     .                   unsafe {
    13 ( 0.00%)              let layout = Layout::for_value_raw(ptr.as_ptr());
    33 ( 0.00%)              if layout.size() != 0 {
    20 ( 0.00%)                  self.1.deallocate(From::from(ptr.cast()), layout);
   600 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::alloc::Global as core::alloc::Allocator>::deallocate (5x)
     .                       }
     .                   }
    14 ( 0.00%)      }
     .           }
     .           
     .           #[cfg(not(no_global_oom_handling))]
     .           #[stable(feature = "rust1", since = "1.0.0")]
     .           impl<T: Default> Default for Box<T> {
     .               /// Creates a `Box<T>`, with the `Default` value for T.
     .               #[inline]
     .               fn default() -> Self {
-- line 1695 ----------------------------------------
-- line 1734 ----------------------------------------
     .               ///
     .               /// // The value is the same
     .               /// assert_eq!(x, y);
     .               ///
     .               /// // But they are unique objects
     .               /// assert_ne!(&*x as *const i32, &*y as *const i32);
     .               /// ```
     .               #[inline]
     3 ( 0.00%)      fn clone(&self) -> Self {
     .                   // Pre-allocate memory to allow writing the cloned value directly.
     5 ( 0.00%)          let mut boxed = Self::new_uninit_in(self.1.clone());
   484 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:alloc::boxed::Box<T,A>::new_uninit_in (1x)
     2 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:<alloc::alloc::Global as core::clone::Clone>::clone (1x)
     .                   unsafe {
     4 ( 0.00%)              (**self).clone_to_uninit(boxed.as_mut_ptr().cast());
     3 ( 0.00%)              boxed.assume_init()
     .                   }
     2 ( 0.00%)      }
     .           
     .               /// Copies `source`'s contents into `self` without creating a new allocation.
     .               ///
     .               /// # Examples
     .               ///
     .               /// ```
     .               /// let x = Box::new(5);
     .               /// let mut y = Box::new(10);
-- line 1757 ----------------------------------------

    43 ( 0.00%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs
--------------------------------------------------------------------------------
Ir               

-- line 1490 ----------------------------------------
      .           /// Therefore, implementations must not require the user to uphold
      .           /// any safety invariants.
      .           ///
      .           /// This intrinsic does not have a stable counterpart.
      .           #[unstable(feature = "core_intrinsics", issue = "none")]
      .           #[rustc_nounwind]
      .           #[inline(always)]
      .           pub const fn likely(b: bool) -> bool {
     18 ( 0.00%)      if b {
      .                   true
      .               } else {
      .                   cold_path();
      .                   false
      .               }
      .           }
      .           
      .           /// Hints to the compiler that branch condition is likely to be false.
-- line 1506 ----------------------------------------
-- line 1513 ----------------------------------------
      .           /// Therefore, implementations must not require the user to uphold
      .           /// any safety invariants.
      .           ///
      .           /// This intrinsic does not have a stable counterpart.
      .           #[unstable(feature = "core_intrinsics", issue = "none")]
      .           #[rustc_nounwind]
      .           #[inline(always)]
      .           pub const fn unlikely(b: bool) -> bool {
128,030 ( 0.11%)      if b {
      .                   cold_path();
      .                   true
      .               } else {
      .                   false
      .               }
      .           }
      .           
      .           /// Returns either `true_val` or `false_val` depending on condition `b` with a
-- line 1529 ----------------------------------------
-- line 3866 ----------------------------------------
      .                   @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :
      .                   #[noinline]
      .                   if const
      .                       $(#[$compiletime_attr:meta])* $compiletime:block
      .                   else
      .                       $(#[$runtime_attr:meta])* $runtime:block
      .               ) => {{
      .                   $(#[$runtime_attr])*
192,110 ( 0.16%)          fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {
      .                       $runtime
     30 ( 0.00%)          }
      .           
      .                   $(#[$compiletime_attr])*
      .                   const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {
      .                       // Don't warn if one of the arguments is unused.
      .                       $(let _ = $arg;)*
      .           
      .                       $compiletime
      .                   }
      .           
     30 ( 0.00%)          const_eval_select(($($val,)*), compiletime, runtime)
    410 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:core::ub_checks::maybe_is_nonoverlapping::runtime (10x)
      .               }},
      .               // We support leaving away the `val` expressions for *all* arguments
      .               // (but not for *some* arguments, that's too tricky).
      .               (
      .                   @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :
      .                   if const
      .                       $(#[$compiletime_attr:meta])* $compiletime:block
      .                   else
-- line 3894 ----------------------------------------
-- line 4404 ----------------------------------------
      .           #[cfg_attr(
      .               not(bootstrap),
      .               rustc_allowed_through_unstable_modules = "import this function via `std::mem` instead"
      .           )]
      .           #[rustc_const_stable(feature = "const_intrinsic_copy", since = "1.83.0")]
      .           #[inline(always)]
      .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .           #[rustc_diagnostic_item = "ptr_copy_nonoverlapping"]
     15 ( 0.00%)  pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {
      .               #[rustc_intrinsic_const_stable_indirect]
      .               #[rustc_nounwind]
      .               #[rustc_intrinsic]
      .               #[rustc_intrinsic_must_be_overridden]
      .               const unsafe fn copy_nonoverlapping<T>(_src: *const T, _dst: *mut T, _count: usize) {
      .                   unreachable!()
      .               }
      .           
-- line 4420 ----------------------------------------
-- line 4423 ----------------------------------------
      .                   "ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \
      .                   and the specified memory ranges do not overlap",
      .                   (
      .                       src: *const () = src as *const (),
      .                       dst: *mut () = dst as *mut (),
      .                       size: usize = size_of::<T>(),
      .                       align: usize = align_of::<T>(),
      .                       count: usize = count,
     20 ( 0.00%)          ) => {
     60 ( 0.00%)              let zero_size = count == 0 || size == 0;
     60 ( 0.00%)              ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)
     70 ( 0.00%)                  && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)
      .                           && ub_checks::maybe_is_nonoverlapping(src, dst, size, count)
      .                   }
      .               );
      .           
      .               // SAFETY: the safety contract for `copy_nonoverlapping` must be
      .               // upheld by the caller.
     30 ( 0.00%)      unsafe { copy_nonoverlapping(src, dst, count) }
      .           }
      .           
      .           /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source
      .           /// and destination may overlap.
      .           ///
      .           /// If the source and destination will *never* overlap,
      .           /// [`copy_nonoverlapping`] can be used instead.
      .           ///
-- line 4449 ----------------------------------------
-- line 4599 ----------------------------------------
      .           #[cfg_attr(
      .               not(bootstrap),
      .               rustc_allowed_through_unstable_modules = "import this function via `std::mem` instead"
      .           )]
      .           #[rustc_const_stable(feature = "const_ptr_write", since = "1.83.0")]
      .           #[inline(always)]
      .           #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces
      .           #[rustc_diagnostic_item = "ptr_write_bytes"]
      1 ( 0.00%)  pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {
      .               #[rustc_intrinsic_const_stable_indirect]
      .               #[rustc_nounwind]
      .               #[rustc_intrinsic]
      .               #[rustc_intrinsic_must_be_overridden]
      .               const unsafe fn write_bytes<T>(_dst: *mut T, _val: u8, _count: usize) {
      .                   unreachable!()
      .               }
      .           
-- line 4615 ----------------------------------------
-- line 4619 ----------------------------------------
      .                       check_language_ub,
      .                       "ptr::write_bytes requires that the destination pointer is aligned and non-null",
      .                       (
      .                           addr: *const () = dst as *const (),
      .                           align: usize = align_of::<T>(),
      .                           zero_size: bool = T::IS_ZST || count == 0,
      .                       ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, zero_size)
      .                   );
      5 ( 0.00%)          write_bytes(dst, val, count)
     11 ( 0.00%)  => ???:__memset_avx2_unaligned_erms (1x)
      .               }
      .           }
      .           
      .           /// Returns the minimum of two `f16` values.
      .           ///
      .           /// Note that, unlike most intrinsics, this is safe to call;
      .           /// it does not require an `unsafe` block.
      .           /// Therefore, implementations must not require the user to uphold
-- line 4635 ----------------------------------------

 64,062 ( 0.05%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs
--------------------------------------------------------------------------------
Ir               

-- line 179 ----------------------------------------
      .               }
      .           }
      .           
      .           // Separate impls for signed ranges because the distance within a signed range can be larger
      .           // than the signed::MAX value. Therefore `as` casting to the signed type would be incorrect.
      .           macro_rules! step_signed_methods {
      .               ($unsigned: ty) => {
      .                   #[inline]
191,976 ( 0.16%)          unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
      .                       // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
 63,992 ( 0.05%)              unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
127,984 ( 0.11%)          }
      .           
      .                   #[inline]
      .                   unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
      .                       // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
      .                       unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
      .                   }
      .               };
      .           }
      .           
      .           macro_rules! step_unsigned_methods {
      .               () => {
      .                   #[inline]
238,420 ( 0.20%)          unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
      .                       // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
      .                       unsafe { start.unchecked_add(n as Self) }
 68,120 ( 0.06%)          }
      .           
      .                   #[inline]
      .                   unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
      .                       // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
      .                       unsafe { start.unchecked_sub(n as Self) }
      .                   }
      .               };
      .           }
-- line 214 ----------------------------------------
-- line 254 ----------------------------------------
      .                   $(
      .                       #[allow(unreachable_patterns)]
      .                       #[unstable(feature = "step_trait", reason = "recently redesigned", issue = "42168")]
      .                       impl Step for $u_narrower {
      .                           step_identical_methods!();
      .                           step_unsigned_methods!();
      .           
      .                           #[inline]
     12 ( 0.00%)                  fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
      6 ( 0.00%)                      if *start <= *end {
      .                                   // This relies on $u_narrower <= usize
      6 ( 0.00%)                          let steps = (*end - *start) as usize;
     14 ( 0.00%)                          (steps, Some(steps))
      .                               } else {
      .                                   (0, None)
      .                               }
      2 ( 0.00%)                  }
      .           
      .                           #[inline]
      .                           fn forward_checked(start: Self, n: usize) -> Option<Self> {
      .                               match Self::try_from(n) {
      .                                   Ok(n) => start.checked_add(n),
      .                                   Err(_) => None, // if n is out of range, `unsigned_start + n` is too
      .                               }
      .                           }
-- line 278 ----------------------------------------
-- line 755 ----------------------------------------
      .                       Step::backward_checked(self.end.clone(), taken).expect("`Step` invariants not upheld");
      .           
      .                   NonZero::new(n - taken).map_or(Ok(()), Err)
      .               }
      .           }
      .           
      .           impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {
      .               #[inline]
102,207 ( 0.09%)      fn spec_next(&mut self) -> Option<T> {
170,354 ( 0.14%)          if self.start < self.end {
102,180 ( 0.09%)              let old = self.start;
      .                       // SAFETY: just checked precondition
204,360 ( 0.17%)              self.start = unsafe { Step::forward_unchecked(old, 1) };
715,260 ( 0.61%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<usize as core::iter::range::Step>::forward_unchecked (34,060x)
 68,120 ( 0.06%)              Some(old)
      .                   } else {
      9 ( 0.00%)              None
      .                   }
136,276 ( 0.12%)      }
      .           
      .               #[inline]
      .               fn spec_nth(&mut self, n: usize) -> Option<T> {
      .                   if let Some(plus_n) = Step::forward_checked(self.start, n) {
      .                       if plus_n < self.end {
      .                           // SAFETY: just checked precondition
      .                           self.start = unsafe { Step::forward_unchecked(plus_n, 1) };
      .                           return Some(plus_n);
-- line 780 ----------------------------------------
-- line 840 ----------------------------------------
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<A: Step> Iterator for ops::Range<A> {
      .               type Item = A;
      .           
      .               #[inline]
 68,138 ( 0.06%)      fn next(&mut self) -> Option<A> {
 34,069 ( 0.03%)          self.spec_next()
1,600,964 ( 1.35%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<core::ops::range::Range<T> as core::iter::range::RangeIteratorImpl>::spec_next (34,069x)
 68,138 ( 0.06%)      }
      .           
      .               #[inline]
     10 ( 0.00%)      fn size_hint(&self) -> (usize, Option<usize>) {
     10 ( 0.00%)          if self.start < self.end {
      6 ( 0.00%)              Step::steps_between(&self.start, &self.end)
     48 ( 0.00%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<usize as core::iter::range::Step>::steps_between (2x)
      .                   } else {
      .                       (0, Some(0))
      .                   }
      4 ( 0.00%)      }
      .           
      .               #[inline]
      .               fn count(self) -> usize {
      .                   if self.start < self.end {
      .                       Step::steps_between(&self.start, &self.end).1.expect("count overflowed usize")
      .                   } else {
      .                       0
      .                   }
-- line 867 ----------------------------------------
-- line 1148 ----------------------------------------
      .                   }
      .           
      .                   try { accum }
      .               }
      .           }
      .           
      .           impl<T: TrustedStep> RangeInclusiveIteratorImpl for ops::RangeInclusive<T> {
      .               #[inline]
576,024 ( 0.49%)      fn spec_next(&mut self) -> Option<T> {
448,008 ( 0.38%)          if self.is_empty() {
 64,008 ( 0.05%)              return None;
      .                   }
896,000 ( 0.76%)          let is_iterating = self.start < self.end;
768,016 ( 0.65%)          Some(if is_iterating {
      .                       // SAFETY: just checked precondition
383,952 ( 0.32%)              let n = unsafe { Step::forward_unchecked(self.start, 1) };
1,471,816 ( 1.25%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<i64 as core::iter::range::Step>::forward_unchecked (63,992x)
 63,992 ( 0.05%)              mem::replace(&mut self.start, n)
      .                   } else {
 64,008 ( 0.05%)              self.exhausted = true;
128,016 ( 0.11%)              self.start
      .                   })
832,040 ( 0.70%)      }
      .           
      .               #[inline]
      .               fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
      .               where
      .                   Self: Sized,
      .                   F: FnMut(B, T) -> R,
      .                   R: Try<Output = B>,
      .               {
-- line 1177 ----------------------------------------
-- line 1243 ----------------------------------------
      .               }
      .           }
      .           
      .           #[stable(feature = "inclusive_range", since = "1.26.0")]
      .           impl<A: Step> Iterator for ops::RangeInclusive<A> {
      .               type Item = A;
      .           
      .               #[inline]
384,016 ( 0.32%)      fn next(&mut self) -> Option<A> {
192,008 ( 0.16%)          self.spec_next()
8,063,872 ( 6.82%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:<core::ops::range::RangeInclusive<T> as core::iter::range::RangeInclusiveIteratorImpl>::spec_next (192,008x)
384,016 ( 0.32%)      }
      .           
      .               #[inline]
      .               fn size_hint(&self) -> (usize, Option<usize>) {
      .                   if self.is_empty() {
      .                       return (0, Some(0));
      .                   }
      .           
      .                   let hint = Step::steps_between(&self.start, &self.end);
-- line 1261 ----------------------------------------

290,074 ( 0.25%)  <counts for unidentified lines in /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs>

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs
--------------------------------------------------------------------------------
Ir               

-- line 290 ----------------------------------------
      .               /// ```
      .               /// use std::sync::Mutex;
      .               ///
      .               /// let mutex = Mutex::new(0);
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
      .               #[rustc_const_stable(feature = "const_locks", since = "1.63.0")]
      .               #[inline]
      3 ( 0.00%)      pub const fn new(t: T) -> Mutex<T> {
     10 ( 0.00%)          Mutex { inner: sys::Mutex::new(), poison: poison::Flag::new(), data: UnsafeCell::new(t) }
     30 ( 0.00%)  => ???:__memcpy_avx_unaligned_erms (1x)
      2 ( 0.00%)      }
      .           
      .               /// Returns the contained value by cloning it.
      .               ///
      .               /// # Errors
      .               ///
      .               /// If another user of this mutex panicked while holding the mutex, then
      .               /// this call will return an error instead.
      .               ///
-- line 308 ----------------------------------------
-- line 427 ----------------------------------------
      .               /// let c_mutex = Arc::clone(&mutex);
      .               ///
      .               /// thread::spawn(move || {
      .               ///     *c_mutex.lock().unwrap() = 10;
      .               /// }).join().expect("thread::spawn failed");
      .               /// assert_eq!(*mutex.lock().unwrap(), 10);
      .               /// ```
      .               #[stable(feature = "rust1", since = "1.0.0")]
224,021 ( 0.19%)      pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {
      .                   unsafe {
 32,003 ( 0.03%)              self.inner.lock();
      .                       MutexGuard::new(self)
      .                   }
 64,006 ( 0.05%)      }
      .           
      .               /// Attempts to acquire this lock.
      .               ///
      .               /// If the lock could not be acquired at this time, then [`Err`] is returned.
      .               /// Otherwise, an RAII guard is returned. The lock will be unlocked when the
      .               /// guard is dropped.
      .               ///
      .               /// This function does not block.
-- line 448 ----------------------------------------
-- line 640 ----------------------------------------
      .                   }
      .                   d.field("poisoned", &self.poison.get());
      .                   d.finish_non_exhaustive()
      .               }
      .           }
      .           
      .           impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {
      .               unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {
512,048 ( 0.43%)          poison::map_result(lock.poison.guard(), |guard| MutexGuard { lock, poison: guard })
2,720,255 ( 2.30%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs:std::sync::poison::Flag::guard (32,003x)
1,280,120 ( 1.08%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs:std::sync::poison::map_result (32,003x)
      .               }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: ?Sized> Deref for MutexGuard<'_, T> {
      .               type Target = T;
      .           
 64,003 ( 0.05%)      fn deref(&self) -> &T {
 64,003 ( 0.05%)          unsafe { &*self.lock.data.get() }
 64,003 ( 0.05%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: ?Sized> DerefMut for MutexGuard<'_, T> {
 67,328 ( 0.06%)      fn deref_mut(&mut self) -> &mut T {
 67,328 ( 0.06%)          unsafe { &mut *self.lock.data.get() }
 67,328 ( 0.06%)      }
      .           }
      .           
      .           #[stable(feature = "rust1", since = "1.0.0")]
      .           impl<T: ?Sized> Drop for MutexGuard<'_, T> {
      .               #[inline]
128,012 ( 0.11%)      fn drop(&mut self) {
      .                   unsafe {
160,015 ( 0.14%)              self.lock.poison.done(&self.poison);
1,472,138 ( 1.25%)  => /home/akshay_kumar/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison.rs:std::sync::poison::Flag::done (32,003x)
 96,009 ( 0.08%)              self.lock.inner.unlock();
      .                   }
 64,006 ( 0.05%)      }
      .           }
      .           
      .           #[stable(feature = "std_debug", since = "1.16.0")]
      .           impl<T: ?Sized + fmt::Debug> fmt::Debug for MutexGuard<'_, T> {
      .               fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      .                   fmt::Debug::fmt(&**self, f)
      .               }
      .           }
-- line 684 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/core/src/alloc/layout.rs
  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/core/src/ptr/alignment.rs
  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/alloc.rs
  /rustc/05f9846f893b09a1be1fc8560e33fc3c815cfecb/library/std/src/sys/alloc/unix.rs
  /usr/src/debug/glibc-2.40-24.fc41.x86_64/elf/dl-lookup.c

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
99,293,418 (84.03%)  events annotated

